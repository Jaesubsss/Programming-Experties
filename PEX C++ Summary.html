<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>C - Boring part</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <ul>
<li><a href="#c---boring-part">C - Boring part</a>
<ul>
<li><a href="#basic">Basic</a>
<ul>
<li><a href="#return-0-vs-return-1">return 0 vs return 1</a></li>
<li><a href="#printf">printf();</a></li>
</ul>
</li>
<li><a href="#data-types-and-control-constructs">Data types and control constructs</a>
<ul>
<li><a href="#size-of-data-type">Size of data type</a></li>
<li><a href="#%ED%98%95%EB%B3%80%ED%99%98">형변환</a></li>
<li><a href="#%EB%B0%98%EB%B3%B5%EB%AC%B8">반복문</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-1">Lecture 1</a>
<ul>
<li><a href="#identifier">Identifier</a></li>
<li><a href="#basic-data-types">Basic data types</a>
<ul>
<li><a href="#local-and-global">local and global</a></li>
<li><a href="#const">const</a></li>
</ul>
</li>
<li><a href="#operator">Operator</a></li>
<li><a href="#data-container">Data Container</a></li>
<li><a href="#storage-classes">Storage classes</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#calling-function">Calling function</a></li>
<li><a href="#math-functions">Math functions</a></li>
<li><a href="#random-number">random number</a></li>
</ul>
</li>
<li><a href="#lecture-2">Lecture 2</a>
<ul>
<li><a href="#inline-function">Inline function</a></li>
<li><a href="#recursion-vs-iteration">Recursion vs Iteration</a></li>
<li><a href="#pointers-and-references">Pointers and References</a>
<ul>
<li><a href="#how-to-return-more-than-one-valueitem">how to return more than one value/item?</a></li>
<li><a href="#call-by">Call by</a>
<ul>
<li><a href="#pointer-and-reference">Pointer and Reference?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#const-keyword">Const keyword</a></li>
<li><a href="#function-overloading">Function overloading</a></li>
<li><a href="#polymorphic-functions-with-templates">Polymorphic functions with templates</a></li>
<li><a href="#lambda-functions">Lambda Functions</a></li>
<li><a href="#container">Container</a>
<ul>
<li><a href="#array">Array</a></li>
<li><a href="#which-container">Which container?</a>
<ul>
<li><a href="#vector">Vector</a></li>
<li><a href="#map">map</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#structure-and-classes">Structure and Classes</a>
<ul>
<li><a href="#struct">Struct</a></li>
<li><a href="#class">Class</a>
<ul>
<li><a href="#getter-setter">Getter, Setter</a></li>
</ul>
</li>
<li><a href="#constructor">Constructor</a>
<ul>
<li><a href="#initialization-list">Initialization list</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-3">Lecture 3</a>
<ul>
<li><a href="#memorization">Memorization</a></li>
<li><a href="#destructor">Destructor</a></li>
<li><a href="#static-members">Static members</a></li>
<li><a href="#const-member-function">Const member function</a></li>
<li><a href="#c-stdstring">C++ std::string</a></li>
<li><a href="#input-output-and-file">Input, Output and File</a>
<ul>
<li><a href="#opening-a-file">Opening a file</a>
<ul>
<li><a href="#openmode">Openmode</a></li>
</ul>
</li>
<li><a href="#stringstream">Stringstream</a></li>
<li><a href="#filesystem">Filesystem</a>
<ul>
<li><a href="#preprocessor">Preprocessor</a></li>
</ul>
</li>
<li><a href="#traversing-a-directory">Traversing a directory</a></li>
<li><a href="#get-home-directory">Get home directory</a></li>
<li><a href="#formatted-output">Formatted Output</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-4">Lecture 4</a>
<ul>
<li><a href="#inheritance">Inheritance</a>
<ul>
<li><a href="#base-class-constructor">Base Class Constructor</a></li>
<li><a href="#composition">Composition</a></li>
<li><a href="#multiple-inharitance">Multiple Inharitance</a></li>
<li><a href="#abstract-class">Abstract Class</a></li>
<li><a href="#mixin">Mixin</a></li>
<li><a href="#virtual-functions">Virtual Functions</a>
<ul>
<li><a href="#using-pointer-and-reference">Using Pointer and Reference</a></li>
<li><a href="#using-template-and-auto">Using Template and Auto</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#stylistic-rules">Stylistic rules</a></li>
<li><a href="#regex">Regex</a>
<ul>
<li><a href="#regex-functions">regex functions</a></li>
<li><a href="#command-line-options">Command Line Options</a>
<ul>
<li><a href="#argc">argc</a></li>
<li><a href="#argv">argv</a></li>
<li><a href="#argparse">argparse</a></li>
<li><a href="#popl---program-options-parser-library">Popl - Program Options Parser Library</a></li>
<li><a href="#flagsh">flags.h</a></li>
<li><a href="#structopt">Structopt</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#lecture-5">Lecture 5</a>
<ul>
<li><a href="#friends-function">Friends Function</a></li>
<li><a href="#copy-constructor">Copy Constructor</a></li>
<li><a href="#this-pointer">This pointer</a></li>
<li><a href="#operator-overloading">Operator overloading</a></li>
<li><a href="#namespace">Namespace</a>
<ul>
<li><a href="#nested-namespace">Nested namespace</a></li>
</ul>
</li>
<li><a href="#function-template">Function Template</a></li>
<li><a href="#class-template">Class Template</a></li>
<li><a href="#standard-template-library-stl">Standard Template Library (STL)</a>
<ul>
<li><a href="#set-vs-vector-vs-map">Set vs Vector vs Map</a></li>
<li><a href="#pair-and-tuple">Pair and Tuple</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="c---boring-part">C - Boring part</h1>
<h2 id="basic">Basic</h2>
<h3 id="return-0-vs-return-1">return 0 vs return 1</h3>
<p>C와 C++에서 return 0과 return 1은 함수가 종료될 때 반환하는 값에 차이를 두는 구문이다. 특히, 메인 함수(main 함수)에서 주로 사용되며, 그 값은 프로그램의 종료 상태를 나타낸다.</p>
<ol>
<li>
<p>return 0</p>
<ul>
<li>성공적인 종료를 의미한다.</li>
<li>대부분의 운영 체제는 0을 성공적인 프로그램 실행을 나타내는 값으로 해석한다.</li>
<li>따라서 return 0;을 하면 프로그램이 정상적으로 종료되었음을 의미한다.</li>
</ul>
</li>
<li>
<p>return 1 (또는 다른 비 0 값)</p>
<ul>
<li>오류 또는 비정상적인 종료를 의미한다.</li>
<li>비 0 값을 반환하면, 일반적으로 프로그램이 오류가 발생했거나 비정상적으로 종료되었음을 나타낸다.</li>
<li>관례적으로 1은 일반적인 오류를 나타내는 경우가 많지만, 1 외에도 다양한 값이 상황에 맞게 사용될 수 있다. 예를 들어, 특정 오류에 대해 다른 값을 반환할 수 있다.</li>
</ul>
</li>
</ol>
<h3 id="printf">printf();</h3>
<p><code>print</code>로 대표적으로 사용되는 녀석인데, 사용이 좀 독특하다. 출력할 문자열 내에 형식 지정자를 끼워넣고, 문자열 외부에서 그 형식 지정자에 들어갈 변수를 순서대로 넣어준다.</p>
<pre><code class="language-c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-type">float</span> b = <span class="hljs-number">3.14</span>;
<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;

<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;정수: %d, 실수: %f, 문자: %c\n&quot;</span>, a, b, c);
<span class="hljs-comment">// 출력: 정수: 10, 실수: 3.140000, 문자: A</span>
</code></pre>
<p>형식 지정자는 다음과 같다.</p>
<ul>
<li><code>%d</code>: 정수형(<code>int</code>)</li>
<li><code>%f</code>: 실수형(<code>float, double</code>)</li>
<li><code>%c</code>: 문자형(<code>char</code>)</li>
<li><code>%s</code>: 문자열(<code>char *</code>)</li>
<li><code>%x</code>, <code>%X</code>: 16진수 출력</li>
<li><code>%o</code>: 8진수 출력</li>
<li><code>%%</code>: % 문자 출력</li>
</ul>
<h3 id="scanf">scanf();</h3>
<p>뭔가 입력을 받을 때 사용되는 함수로써, 일반적인 사용법은 <code>printf()</code>와 같다.</p>
<pre><code class="language-c"><span class="hljs-type">int</span> a;
<span class="hljs-type">float</span> b;
<span class="hljs-type">char</span> c;

<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %f %c&quot;</span>, &amp;a, &amp;b, &amp;c);
</code></pre>
<p>형식지정자에 따라, 상응하는 데이터형에 따른 입력을 받는다.</p>
<h2 id="data-types-and-control-constructs">Data types and control constructs</h2>
<h3 id="size-of-data-type">Size of data type</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:center">Bytes</th>
<th style="text-align:left">Minimum range</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:center">1</td>
<td style="text-align:left">[-128, +127]</td>
</tr>
<tr>
<td style="text-align:left">unsigned char</td>
<td style="text-align:center">1</td>
<td style="text-align:left">[0, 255]</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:center">2</td>
<td style="text-align:left">[-32,768, +32,767]</td>
</tr>
<tr>
<td style="text-align:left">unsigned short</td>
<td style="text-align:center">2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:center">2</td>
<td style="text-align:left">[-32,768, +32,767]</td>
</tr>
<tr>
<td style="text-align:left">unsigned int</td>
<td style="text-align:center">2</td>
<td style="text-align:left">[0, 65,535]</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:center">4</td>
<td style="text-align:left">[-2,147,483,647, +2,147,483,647]</td>
</tr>
<tr>
<td style="text-align:left">unsigned long</td>
<td style="text-align:center">4</td>
<td style="text-align:left">[0, 4,294,967,295]</td>
</tr>
<tr>
<td style="text-align:left">long long</td>
<td style="text-align:center">8</td>
<td style="text-align:left">[-9,223,372,036,854,775,808, +9,223,372,036,854,775,807]</td>
</tr>
<tr>
<td style="text-align:left">unsigned long long</td>
<td style="text-align:center">8</td>
<td style="text-align:left">[0, 18,446,744,073,709,551,615]</td>
</tr>
</tbody>
</table>
<p>long long &gt; long &gt; int &gt; short &gt; char</p>
<h3 id="형변환">형변환</h3>
<p>어떤 데이터의 형을 변환하고싶다면 앞에 <code>(data type)</code>를 사용하면 된다.</p>
<pre><code class="language-c"><span class="hljs-type">float</span> res = ( <span class="hljs-type">float</span> ) i / k;
</code></pre>
<h3 id="반복문">반복문</h3>
<p>for loop의 형태가 꽤나 헷갈린다.</p>
<pre><code class="language-c"><span class="hljs-keyword">for</span> (i =<span class="hljs-number">0</span>; i &lt;=<span class="hljs-number">10</span>; i=i +<span class="hljs-number">1</span>){}
</code></pre>
<p>이런 형태이다.</p>
<p>while의 형태는 별로 다르지 않다.</p>
<pre><code class="language-c"><span class="hljs-keyword">while</span> (조건문) {}
</code></pre>
<p>do while loop도 자주 쓰이니 알아두자.</p>
<pre><code class="language-c"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;
<span class="hljs-keyword">do</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;j=%d\n&quot;</span>, j++);
} <span class="hljs-keyword">while</span> (j &lt; <span class="hljs-number">10</span>);
</code></pre>
<h3 id="string">String</h3>
<p>String은 Character의 배열이다. 이 경우, 배열의 마지막엔 항상 문장의 끝을 의미하는 &quot;널 문자&quot; <code>'\0'</code>이 들어가야 한다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">char</span> a[<span class="hljs-number">23</span>] = {<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>};
    
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, a);    <span class="hljs-comment">// 1. 문자열 전체 출력</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, a[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 2. 첫 번째 문자 출력</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 3. 첫 번째 문자의 ASCII 값 출력, 80</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">7</span>]); <span class="hljs-comment">// 4. 7번째 문자의 ASCII 값 (널 문자) 출력, 0</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><code>%d</code>는 정수형을 의미하는 형식 지정자로써, 이것으로 호출하면 아스키값을 출력한다.</p>
<h3 id="pointer">Pointer</h3>
<p>매우 중요한 개념이고, 매우 헷갈리는 개념이다.</p>
<p>포인터는 메모리 주소를 저장하는 변수이다. 일반 변수는 값을 저장하지만, 포인터는 <strong>값이 저장된 메모리 주소</strong>를 저장한다.</p>
<p>포인터는 다음과 같이 선언될 수 있다.</p>
<pre><code class="language-c"><span class="hljs-type">int</span> i = <span class="hljs-number">99</span>;
<span class="hljs-type">int</span> *pointer_i = &amp;i;
</code></pre>
<p>이때, <code>*pointer_i</code>는 포인터로써 선언이 되는데, 이 주소값을 주소연산자 <code>&amp;</code>를 통해, <code>i</code>의 주소를 포인터에 할당해 주는 것이다.</p>
<p>포인터를 이용해 값을 참조할 수 있다.</p>
<pre><code class="language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i is %d, *pointer_i is %d\n&quot;</span>, i, *pointer_i);
</code></pre>
<p>이때 <code>i</code>는 변수 i의 값을 가져와 99를 출력한다.</p>
<p><code>*pointer_i</code>는 해당 변수가 가리키는 주소에 있는 값을 가져와 출력한다. 따라서, 똑같이 99를 출력한다.</p>
<p>자! 이제 여기서 중요한 포인트이다. <code>*</code>연산자가 붙으면 그 주소의 값을 참조하는건데, 얘가 없으면 어떻게 될까?</p>
<pre><code class="language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p, %p\n&quot;</span>, &amp;i, pointer_i);
</code></pre>
<p>먼저, <code>&amp;i</code>는 주소연산자 <code>&amp;</code>를 통해, 변수 i의 주소를 가져온다.</p>
<p>그리고, <code>pointer_i</code>는 변수 i의 주소를 저장한 포인터이므로, 변수 i가 저장된 주소를 가져온다.</p>
<p>따라서, 두 값은 동일한 메모리 주소를 출력한다. (예: <code>0x7ffee6a09a8c</code>)</p>
<h2 id="function">Function</h2>
<p>C 언어에서 함수는 다음과 같은 세 가지 구성 요소로 이루어져 있다:</p>
<ul>
<li>반환형 (Return Type): 함수가 반환하는 값의 데이터 타입.</li>
<li>함수 이름 (Function Name): 함수를 호출할 때 사용하는 이름.</li>
<li>매개변수 (Parameters): 함수가 입력받는 데이터(인자).</li>
<li>함수 본체 (Function Body): 함수가 수행할 작업을 정의하는 코드.</li>
</ul>
<pre><code class="language-c">반환형 함수이름(매개변수 목록) {
    <span class="hljs-comment">// 함수 본체 (실제 코드 실행 부분)</span>
    <span class="hljs-keyword">return</span> 반환값;  <span class="hljs-comment">// 반환형이 void인 경우에는 return을 생략할 수 있음</span>
}
</code></pre>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-comment">// 함수 선언 (프로토타입)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;

<span class="hljs-comment">// main 함수 (프로그램의 시작점)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> result = add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// add 함수 호출</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, result);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 함수 정의</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;  <span class="hljs-comment">// a와 b를 더한 값을 반환</span>
}
</code></pre>
<h3 id="local-vs-global">local vs global</h3>
<h4 id="local">local</h4>
<p>local variable은 코드블록 내부에서 선언된 변수이다. 이 변수는 변수가 선언된 블록 내에서만 접근이 가능하다.</p>
<p>로컬은 또한 선언된 함수가 호출될 때 생성되고, 함수가 종료되면 메모리에서 사라진다.</p>
<p>그러나, 이 로컬 변수는 자동으로 초기화 되지 않으므로, 반드시 명시적으로 초기화해야한다. 그렇지 않은 경우 garbage value가 들어갈 수 있다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">myFunction</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> localVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 지역 변수</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;localVar: %d\n&quot;</span>, localVar);  <span class="hljs-comment">// 지역 변수를 사용할 수 있음</span>
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    myFunction();  <span class="hljs-comment">// 함수 호출</span>
    <span class="hljs-comment">// printf(&quot;%d&quot;, localVar);  // 오류! localVar는 myFunction() 내부에서만 접근 가능</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="global">global</h4>
<p>global variable은 모든 함수 외부에서 선언된 변수이다. 선언된 지점에서 프로그램 전체에서 접근할 수 있으며, 모두 공유되는 변수이다.</p>
<p>이는 프로그램이 시작될 때 생성되고, 프로그램이 종료될 때 까지 유지된다.</p>
<p>글로벌은 자동으로 초기화되며, 기본적으로 0으로 초기화된다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> globalVar = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 전역 변수</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">myFunction</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;globalVar in myFunction: %d\n&quot;</span>, globalVar);  <span class="hljs-comment">// 전역 변수 사용 가능</span>
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;globalVar in main: %d\n&quot;</span>, globalVar);  <span class="hljs-comment">// 전역 변수 사용 가능</span>
    myFunction();  <span class="hljs-comment">// 함수 호출</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="static-vs-automatic">static vs automatic</h3>
<p><code>static</code> 키워드는 변수가 선언된 위치와 관계없이 변수의 생명 주기를 프로그램의 전체 실행 시간으로 확장시킨다. 즉, <code>static</code> 변수는 한 번 초기화되면 프로그램이 종료될 때까지 메모리에서 유지된다.</p>
<p><code>local static</code> 변수는 함수 내부에서 선언되어도 그 유효 범위는 해당 함수 내에만 한정된다. 하지만 해당 함수가 여러 번 호출되어도 초기화는 단 한 번만 이루어진다.</p>
<p><code>global static</code> 변수는 파일 내에서만 유효하며, 다른 파일에서 접근할 수 없다. 이를 통해 외부에서 접근할 수 없도록 파일 범위의 은닉성을 제공한다.</p>
<p><code>automatic</code> 은 디폴트 값이며, 기본적으로 local 변수이다. 함수나 블록이 호출되거나 실행될 때 자동으로 생성되고, 종료될 때 소멸된다.</p>
<h2 id="array-and-pointers">Array and Pointers</h2>
<h3 id="array">Array</h3>
<p>모두 같은 데이터타입을 공유하는 storage locations의 모임이다.</p>
<pre><code class="language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{
    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];
    a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p>요러면 1이 나오겠죠? 처음에 <code>a[10]</code>은 크기를 명시한 것이다. array는 처음 선언할 때 크기를 같이 선언해주어야 하고, 이는 변경될 수 없다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> points[<span class="hljs-number">31</span>], count;

    <span class="hljs-comment">// 1. 점수 입력</span>
    <span class="hljs-keyword">for</span>(count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">31</span>; count++) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter smiley points for May %d: &quot;</span>, count + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;points[count]);
    }

    <span class="hljs-comment">// 2. 점수 출력</span>
    <span class="hljs-keyword">for</span>(count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">31</span>; count++) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Smiley points for May %d: %d\n&quot;</span>, count + <span class="hljs-number">1</span>, points[count]);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>이때, 중요한 부분이 <code>scanf(&quot;%d&quot;, &amp;points[count]);</code> 이부분이다.</p>
<p><code>&amp;points[count]</code>는 <code>points</code> array에서 <code>count</code>번째 요소의 주소를 가리킨다. 즉, 입력된 point는 저부분에 저장이 되는 것이다.</p>
<p>또한 출력부분에서 <code>points[count]</code>는 <code>count</code>번째에 저장된 요소를 출력하라는 것이다.</p>
<h4 id="multidimensional-arrays">Multidimensional arrays</h4>
<pre><code class="language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{
    <span class="hljs-type">int</span> table[<span class="hljs-number">2</span>][<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>};
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, table [<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]); <span class="hljs-comment">// 8</span>
    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p>요롷게 표를 만들 수 있따.</p>
<h4 id="pointers">Pointers</h4>
<pre><code class="language-c">typename variablename = value ;
typename * pointername ;
pointername = &amp; variablename ;
</code></pre>
<ul>
<li><code>*</code>: indirection operator</li>
<li><code>&amp;</code>: address of</li>
</ul>
<p>변수의 값에는 어떻게 접근할까?</p>
<p>변수의 이름을 직접 호출하여, 값에 직접적으로 접근할 수 있다.</p>
<p>또는, <code>*pointername</code>를 통해 간접적으로 변수에 접근할 수 있다.</p>
<p>포인터를 선언할 때 중요한 점은 <code>*</code>의 위치이다. 보통같으면 딱히 문제가 없는데, 한번에 여러개를 선언할때는 구분이 필요하다.</p>
<pre><code class="language-c"><span class="hljs-type">int</span> *p, i;
<span class="hljs-type">int</span>* p1, p2;
</code></pre>
<p>여기서보면, <code>i</code>는 일반 변수이다. 그러나, <code>p1</code>과 <code>p2</code>는 모두 포인터이다.</p>
<p>array의 사이즈를 보려면, 다음과 같이 사용할 수 있다.</p>
<pre><code class="language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size of int:%zu\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
</code></pre>
<p>포인터를 통해 어떤 배열을 가리킬 수 있다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 13</span>

<span class="hljs-type">int</span> a[MAX] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>};  <span class="hljs-comment">// 크기가 13인 배열 초기화</span>
<span class="hljs-type">int</span> *pointer_a, count;  <span class="hljs-comment">// 정수형 포인터와 반복 제어 변수 선언</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    pointer_a = a;  <span class="hljs-comment">// 포인터가 배열 a의 첫 번째 요소를 가리키도록 설정</span>

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index\tValue\tAddress\n&quot;</span>);  <span class="hljs-comment">// 헤더 출력</span>

    <span class="hljs-comment">// 배열 요소와 그 주소를 출력하는 for 루프</span>
    <span class="hljs-keyword">for</span>(count = <span class="hljs-number">0</span>; count &lt; MAX; count++) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t%d\t%p\n&quot;</span>, count, *pointer_a++, pointer_a);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><code>pointer_a</code>: 정수형 포인터로, 배열 a의 첫 번째 요소를 가리키는 데 사용된다.</p>
<p>배열 <code>a</code>의 이름은 배열의 첫 번째 요소의 주소를 가리키므로, <code>pointer_a</code>에 배열 <code>a</code>의 시작 주소가 할당된다.
따라서, <code>pointer_a</code>는 배열의 첫 번째 요소를 가리키게 된다.</p>
<pre><code class="language-c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t%d\t%p\n&quot;</span>, count, *pointer_a++, pointer_a);
</code></pre>
<p>여기에서, <code>*pointer_a++</code>는 <code>pointer_a</code>가 가리키는 값을 출력한다. 이 표현식은 후위 증가 연산자<code>(++)</code>를 사용하여 먼저 현재 주소가 가리키는 값을 출력하고, 그 후 포인터를 다음 요소로 이동시킨다. 즉, 출력 후 <code>pointer_a</code>가 다음 배열 요소로 이동한다.</p>
<p><code>pointer_a</code>: 배열의 현재 주소를 출력한다. 포인터가 증가되었기 때문에, 다음 요소의 주소가 출력된다.</p>
<pre><code>Index   Value   Address
0       1       0x7ffeed5bc020
1       2       0x7ffeed5bc024
2       3       0x7ffeed5bc028
3       4       0x7ffeed5bc02c
4       5       0x7ffeed5bc030
5       6       0x7ffeed5bc034
...
12      13      0x7ffeed5bc04c
</code></pre>
<p><code>pointer_a++</code>는 4바이트씩 증가한다. 이는 int형이 4바이트를 차지하기 때문에, 다음 메모리 주소는 4바이트 뒤로 이동하게 된다. 즉, 메모리 주소 간의 차이는 <code>sizeof(int)</code>(4바이트)입니다.</p>
<p><code>%p</code>는 메모리 주소를 출력하는데 사용되며, 각 배열 요소의 주소는 4바이트씩 증가한다.</p>
<h2 id="pointers-trees-linked-lists">Pointers, Trees, Linked Lists</h2>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[])</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> i, a[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>); i++) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Entry %d is %d.\n&quot;</span>, i+<span class="hljs-number">1</span>, a[i]);
    }
    fun(a);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[])</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(array)/sizeof(int)=%d\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">array</span>)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
}
</code></pre>
<p>for문: <code>sizeof(a)/sizeof(int)</code>는 배열 a의 요소 개수를 구하는데 사용된다. 여기서 <code>sizeof(a)</code>는 배열의 전체 크기를 바이트 단위로 나타내고, <code>sizeof(int)</code>는 배열의 각 요소의 크기를 나타낸다. 이 결과를 통해 배열의 길이를 구할 수 있다.</p>
<p>따라서 <code>sizeof(array)/sizeof(int)</code>는 항상 8/4 = 2를 반환하게 된다.</p>
<h4 id="pointer-arithmetics">Pointer arithmetics</h4>
<pre><code class="language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">int</span> i, a[<span class="hljs-number">5</span>] = {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>};
<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a[%d]=%d\n&quot;</span>, i, *(a+i));
}
<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p><code>*(a+i)</code>는  배열의 포인터를 사용하여 인덱스 i에 해당하는 값을 출력한다.</p>
<ul>
<li><code>a</code>는 배열의 시작 주소를 나타내는 포인터이다.</li>
<li><code>*(a+i)</code>는 포인터 산술을 이용하여 배열의 i번째 요소에 접근한다. 여기서 <code>a + i</code>는 배열의 <code>i</code>번째 요소의 주소를 나타내며, <code>*</code> 연산자는 그 주소에 있는 값을 가져온다.</li>
</ul>
<p>배열 a의 주소는 변경되지 않으며, 포인터 산술을 통해 각 요소에 접근하는 방식이 동작한다.</p>
<pre><code>a[0]=2
a[1]=4
a[2]=6
a[3]=8
a[4]=10
</code></pre>
<h4 id="melloc">melloc()</h4>
<p><code>melloc</code>함수는 동적 메모리 할당을 가능하게한다. <code>stdlib.h</code> 헤더파일에 포함되어있다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>; <span class="hljs-comment">// 문자열을 가리키는 포인터를 선언</span>
    <span class="hljs-built_in">string</span> = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">96</span>); <span class="hljs-comment">// 96바이트의 메모리를 동적으로 할당. </span>
                                 <span class="hljs-comment">// 이는 95개의 문자와 문자열 끝에 오는 null 문자(\0)를 포함하기 위한 메모리 공간</span>

    <span class="hljs-type">int</span> count;
    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">string</span>;
    <span class="hljs-keyword">for</span>(count = <span class="hljs-number">32</span>; count &lt; <span class="hljs-number">126</span>; count++) {
        *p++ = count;
    }
    *p++ = <span class="hljs-string">&#x27;\0&#x27;</span>;

    <span class="hljs-built_in">puts</span>(<span class="hljs-built_in">string</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-built_in">string</span>);
    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">string</span>); <span class="hljs-comment">// 할당된 메모리 해제</span>

    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p><code>(char*)</code>는 <code>malloc()</code>의 반환값을 <code>char</code> 포인터로 형변환한다.</p>
<h4 id="struct-name">struct name{}</h4>
<p>struct는 C와 C++에서 구조체를 정의하기 위한 키워드다. 구조체는 서로 다른 데이터 타입을 하나의 복합 데이터 타입으로 묶을 수 있는 방법을 제공한다. struct를 사용하면 여러 변수를 하나의 이름 아래 그룹화하여 관리할 수 있다.</p>
<p>선언은 다음과 같이 한다.</p>
<pre><code class="language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">name</span> {</span>
    <span class="hljs-type">char</span> first[<span class="hljs-number">20</span>];
    <span class="hljs-type">char</span> last[<span class="hljs-number">20</span>];
    <span class="hljs-type">int</span> age;
};
</code></pre>
<p>이렇게 구조체를 선언해 놓으면, 아래와 같이 자료형처럼 사용할 수 있다.</p>
<pre><code class="language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">name</span> <span class="hljs-title">person1</span> =</span> {<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>, <span class="hljs-number">30</span>};
</code></pre>
<p>또한, <code>person.last</code>와 같은 방법으로 해당 변수에 접근할 수 있다.</p>
<pre><code class="language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>{</span>
    <span class="hljs-type">char</span> name[<span class="hljs-number">23</span>];
    <span class="hljs-type">int</span> age;
}

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">student</span>;</span>
</code></pre>
<p>요런식으로 원래 <code>struct student</code>를 사용해서 선언해야 했던 저 구조체를 <code>student</code>하나만으로 선언할 수 있다.</p>
<h4 id="typedef">typedef</h4>
<p>typedef는 C와 C++에서 데이터 타입에 새로운 이름을 부여하는 데 사용되는 키워드다. 이를 통해 기존 데이터 타입을 더 읽기 쉽거나 편리하게 사용하기 위한 별칭(alias)을 정의할 수 있다.</p>
<h1 id="lecture-1">Lecture 1</h1>
<p>c++같은 좆같은 언어를 왜 쓰는가? c++은 저수준 언어이기 때문에, 메모리에 직접적인 액세스가 가능하고 강력한 하드웨어 제어능력이 있다. 파이썬같은건 대충 휘뚜루 마뚜루 쓰기엔 좋은데, 대규모 및 고성능 애플리케이션에선 조금 짜친다. c++은 이런 대규모 데이터를 다루기에 좋은데, 마침 bioinformatic이 아주 대규모 데이터를 다루네? 따라서 c++사용은 거의 필수라고 할 수 있다.</p>
<p>또한 C++은 다양한 플랫폼과 운영체제에서 베이직으로 사용되어 이식성이 뛰어나다. 라이브러리도 많고, 시스템 프로그래밍에도 적합하다.</p>
<p>파이썬과 R에서도 c++을 사용할 수 있다. 예를들어, <code>ctypes</code> 모듈은 외부 공유 라이브러리를 사용하여 c함수를 호출할 수 있다. 파이썬에서 기본적으로 제공된다. 또한 <code>SWIG</code>는 c/c++코드와 스크립팅 언어간의 인터페이스를 생성하여, c/c++ 코드를 파이썬에 통합할 수 있도록 한다.</p>
<p>파이썬에서 C API extension을 사용한걸 보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Python.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">myfunc</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * s1)</span></span>;
<span class="hljs-function"><span class="hljs-type">static</span> PyObject *<span class="hljs-title">wrapped_myfunc</span><span class="hljs-params">(PyObject *self,
    PyObject *args)</span> </span>{
  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1;
  <span class="hljs-type">int</span> ival;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PyArg_ParseTuple</span>(args, <span class="hljs-string">&quot;is&quot;</span>, &amp;ival, &amp;s1))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
  ival = <span class="hljs-built_in">myfunc</span>(x, s1);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Py_BuildValue</span>(<span class="hljs-string">&quot;i&quot;</span>, ival);
}
</code></pre>
<p>C코드 컴파일러가 따로 필요하며, 복잡하다.</p>
<p>ctypes 예시를 보자.</p>
<pre><code class="language-python"><span class="hljs-keyword">import</span> ctypes
mydll = ctypes.CDLL(<span class="hljs-string">&quot;./mydll.dll&quot;</span>)
myfunc = mydll.myfunc
myfunc.argtypes = [ctypes.c_int, ctypes.c_char_p]
myfunc.restype = ctypes.c_int
<span class="hljs-built_in">print</span> mydll.myfunc(<span class="hljs-number">22</span>, <span class="hljs-string">&quot;This is a test.&quot;</span>)
</code></pre>
<p>쉽쥬?</p>
<p>마찬가지로 R에서도 c/c++ 환경을 사용할 수 있다. <code>Rcpp</code>라는 패키지를 사용한다.</p>
<pre><code class="language-r">library<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;Rcpp&quot;</span><span class="hljs-punctuation">)</span>
cppFunction<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;
    Rcpp::NumericVector nfun(
    Rcpp::NumericVector a,
    Rcpp::NumericVector b) {

    Rcpp::NumericVector xa(a);
    Rcpp::NumericVector xb(b);
    int n_xa = xa.size(), n_xb = xb.size();
    Rcpp::NumericVector xab(n_xa + n_xb - 1);
    for (int i = 0; i &lt; n_xa; i++) {
        for (int j = 0; j &lt; n_xb; j++) {
            xab[i + j] += xa[i] * xb[j];
        }
    }
    return xab;
}
&quot;</span><span class="hljs-punctuation">)</span>
</code></pre>
<p>이런식으로, R과 python에서 미리 만들어놓은 것들을 C를 이용해 바꿔서 더 빠르게 만들거나, 더 큰 데이터셋에 사용할 수 있도록 바꿀 수 있다.</p>
<p>C++은 C의 업그레이드 버젼으로, C에서 사용한것들을 모두 사용할 수 있고, OOP나 regex와 같은 더 많은 기능들이 들어가있다. c는 버리고  c++을 쓰도록 하자. 그래도 C++을 할려면 c도 결국 할줄 알아야한다..</p>
<p>추가된 기능에 대해 예시를 보도록 하자.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello C World !\n&quot;</span>);
    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p>C에서는 항상 저렇게 <code>printf()</code>를 사용해줬어야 했다.</p>
<p>그러나, C++에서는!</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello C++ World!\n&quot;</span>;
    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<p>요로코롬 신기한 기능이 생겼다. 근데 뭐 사실 다른언어에서 다 print 쓰는데 굳이 저걸 써야하나 싶기도 하고..</p>
<h2 id="identifier">Identifier</h2>
<p>중요한! 식별자부터 알아보도록 하자.  변수, 함수, 클래스, 모듈 또는 다른 사용자 정의 항목을 식별하는 데 사용되는 이름이다. 식별자는 대문자 A부터 Z, 소문자 a부터 z, 또는 밑줄(_)로 시작하며 이어서 문자, 밑줄 및 숫자(0부터 9)가 올 수 있다. C++에서는 @, $, %와 같은 구두점 문자를 식별자 내에서 허용하지 않는다. 또한 C++은 대소문자를 구분한다. <code>myVariable</code>
<code>my_function</code>
<code>_myClass</code>
<code>MyModule</code>
<code>variable123</code> 등은 유효한 이름으로 식별된다. 당연히, 키워드는 identifier로 사용될 수 없다.</p>
<p>주석은 <code>/**/</code>와 <code>//</code>로 사용할 수 있다.</p>
<h2 id="basic-data-types">Basic data types</h2>
<p>C 언어의 유형과 동일하지만 몇 가지 추가 유형이 있다.</p>
<ul>
<li><strong>bool</strong> (부울): 참/거짓을 나타내는 부울 값으로 사용된다.</li>
<li><strong>wchar_t (UTF-16)</strong>: 넓은 문자(wide character)를 나타내며 주로 UTF-16 문자열을 다룰 때 사용된다.</li>
<li>C++에는 <strong>std::string</strong>이라는 정교한 문자열 유형이 있다. strncpy, strcmp 등과 같은 함수를 사용할 필요 없이 간단한 할당 및 비교 연산자를 사용할 수 있다.</li>
<li><strong>enum</strong>: C++에서는 열거형을 정의하는 데 사용되며, 연속된 정수 상수의 집합을 정의한다.</li>
<li><strong>const</strong> VARIABLES: 상수를 정의하는 데 사용되며, 값이 변경되지 않아야 하는 변수에 사용된다.</li>
</ul>
<p>enumeration의 예시를 보자.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">enum</span> { kreuz, pik, karo, herz, dummy=<span class="hljs-number">7</span> };
    <span class="hljs-type">int</span> karte = karo;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Wert von Pik ist: &quot;</span> &lt;&lt; pik &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Wert der Karte: &quot;</span> &lt;&lt; karte &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    karte=dummy;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Wert der Karte: &quot;</span> &lt;&lt; karte &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);
}
</code></pre>
<pre><code>Wert von Pik ist: 1
Wert der Karte: 2
Wert der Karte: 7
</code></pre>
<p>요로코롬 나타나게 된다.</p>
<h3 id="local-and-global">local and global</h3>
<p>local 쓰고싶으면 그냥 함수 안에 쓰면 되고, global을 쓰고싶으면 그냥 함수 밖에 선언하면 된다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// 전역 변수 선언</span>
<span class="hljs-type">int</span> globalVar = <span class="hljs-number">10</span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 전역 변수 globalVar를 출력</span>
    cout &lt;&lt; <span class="hljs-string">&quot;전역 변수 globalVar의 값: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 전역 변수 globalVar를 출력</span>
    cout &lt;&lt; <span class="hljs-string">&quot;전역 변수 globalVar의 값: &quot;</span> &lt;&lt; globalVar &lt;&lt; endl;
    
    <span class="hljs-comment">// func 함수 호출</span>
    <span class="hljs-built_in">func</span>();
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="const">const</h3>
<p>또한, 상수를 정의할때 <code>#define</code>나 <code>const</code>를 사용할 수 있다. 상수는 대문자로 정의하는게 국룰이다. 근데, 예전에는 <code>#define</code>을 사용하여 상수를 적용했지만, 이게 somehow 혼동을 일으키거나 오류를 발생시킬 수 있기 때문에, 일단 냅두지만 <code>const</code>를 사용하는게 권장된다.</p>
<pre><code class="language-cpp"><span class="hljs-comment">// #define을 사용한 상수 정의 (지양하는 방법)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VALUE 100</span>

<span class="hljs-comment">// const 키워드를 사용한 상수 정의</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_VALUE = <span class="hljs-number">100</span>;
</code></pre>
<h2 id="operator">Operator</h2>
<p>operator는 C와 유사하다. 논리 연산자는 &amp;&amp; (and)와 || (or)를 사용하며, 할당 연산자로는 =, +=, -=, *=, /= 등이 있다. 그러나, <strong>비트 연산자</strong>가 있는데, &amp;, |, ^를 사용할 수 있따.</p>
<p>또한, c++에서 추가된것들이 있다.</p>
<ul>
<li>
<p><strong>auto</strong>: auto 키워드는 변수의 자료형을 자동으로 추측하도록 한다. 예를 들어, <code>auto x = 1;</code>은 x가 정수로 추측된다.</p>
</li>
<li>
<p><strong>sizeof</strong>: sizeof 연산자는 데이터 형식 또는 변수의 크기를 반환한다. 예를 들어, <code>sizeof(int)</code>는 정수의 크기를 반환한다.</p>
</li>
<li>
<p><strong>condition ? x : y</strong>: 조건 연산자는 조건식의 결과에 따라 두 개의 값 중 하나를 선택한다. 조건이 참이면 x를 반환하고, 거짓이면 y를 반환한다.</p>
</li>
<li>
<p><strong>. (dot) and -&gt; arrow</strong>: <code>.</code> 연산자는 객체나 구조체의 멤버에 접근할 때 사용된다. <code>-&gt;</code> 연산자는 포인터가 가리키는 객체나 구조체의 멤버에 접근할 때 사용된다.</p>
</li>
<li>
<p><strong>cast like int(3.4)</strong>: 캐스트 연산자를 사용하여 데이터 형식을 변환할 수 있다. 예를 들어, <code>int(3.4)</code>는 실수 3.4를 정수로 변환한다.</p>
</li>
<li>
<p><strong>&amp; pointer</strong>: <code>&amp;</code> 연산자는 변수의 주소를 반환한다. 이는 포인터 변수를 초기화하거나 함수에 참조 매개변수를 전달할 때 유용하다.</p>
</li>
<li>
<p><strong><code>*</code> pointer</strong>: <code>*</code> 연산자는 포인터 변수를 나타냅니다. 이는 포인터가 가리키는 변수의 값을 역참조할 때 사용된다.</p>
</li>
</ul>
<h2 id="data-container">Data Container</h2>
<p>c++에는 신기하고 다양한 컨테이너들이 있다.</p>
<ul>
<li>std::string</li>
<li>std::map (Python의 dictionary, R의 list와 유사)</li>
<li>std::array (크기가 고정된 배열)</li>
<li>std::vector (배열과 유사하지만 크기를 조절할 수 있음)</li>
<li>std::set (map과 유사하지만 값이 없음)</li>
</ul>
<p>뭐 이상한것들이 많은데, 대충 map과 vector만 쓰면 웬만한건 다 할 수 있다. map에 대한 몇가지 기본적인 메서드들을 알아보자.</p>
<ul>
<li><code>begin()</code> - 맵의 첫 번째 요소에 대한 반복자를 반환한다.</li>
<li><code>end()</code> - 맵의 마지막 요소 다음의 이론적 요소에 대한 반복자를 반환한다.</li>
<li><code>size()</code> - 맵에 포함된 요소의 수를 반환한다.</li>
<li><code>empty()</code> - 맵이 비어 있는지 여부를 반환한다.</li>
<li><code>insert(keyvalue, mapvalue)</code> - 새로운 요소를 맵에 추가한다.</li>
<li><code>erase(const g)</code>- 맵에서 키 값 &quot;g&quot;를 제거한다.</li>
<li><code>clear()</code> - 맵에서 모든 요소를 제거한다.</li>
</ul>
<p>써보도록 하자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::string hw = <span class="hljs-string">&quot;Hello World!\n&quot;</span>;
    std::cout &lt;&lt; hw;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Length of String: &quot;</span> &lt;&lt; hw.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;

    std::vector&lt;<span class="hljs-type">int</span>&gt; v = {<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">16</span>, <span class="hljs-number">8</span>};
    std::cout &lt;&lt; <span class="hljs-string">&quot;element at 0: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; std::endl;
    v[<span class="hljs-number">0</span>]++;
    std::cout &lt;&lt; <span class="hljs-string">&quot;element at 0: &quot;</span> &lt;&lt; v[<span class="hljs-number">0</span>] &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">&quot;length of vector: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;

    <span class="hljs-comment">// 새로운 요소 추가 (배열에는 사용할 수 없음)</span>
    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);
    std::cout &lt;&lt; <span class="hljs-string">&quot;last element: &quot;</span> &lt;&lt; v.<span class="hljs-built_in">at</span>(v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &lt;&lt; std::endl;

    std::map&lt;std::string, <span class="hljs-type">char</span>&gt; aaa = { {<span class="hljs-string">&quot;Leu&quot;</span>, <span class="hljs-string">&#x27;L&#x27;</span>} };
    <span class="hljs-comment">// std::map에 데이터 삽입</span>
    aaa.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Cys&quot;</span>, <span class="hljs-string">&#x27;C&#x27;</span>));
    aaa.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Asp&quot;</span>, <span class="hljs-string">&#x27;D&#x27;</span>));
    <span class="hljs-comment">// 자동 쌍(pair) 생성</span>
    aaa.<span class="hljs-built_in">insert</span>({ <span class="hljs-string">&quot;Ala&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span> });
    <span class="hljs-comment">// 더 간단한 삽입</span>
    aaa[<span class="hljs-string">&quot;Asn&quot;</span>] = <span class="hljs-string">&#x27;N&#x27;</span>;
    aaa[<span class="hljs-string">&quot;His&quot;</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;
    std::cout &lt;&lt; <span class="hljs-string">&quot;map size: &quot;</span> &lt;&lt; aaa.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Proline? &quot;</span> &lt;&lt; aaa.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;Pro&quot;</span>) &lt;&lt; std::endl;
    aaa[<span class="hljs-string">&quot;Pro&quot;</span>] = <span class="hljs-string">&#x27;P&#x27;</span>;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Proline? &quot;</span> &lt;&lt; aaa.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;Pro&quot;</span>) &lt;&lt; std::endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code>Hello World!
Length of String: 13
element at 0: 7
element at 0: 8
length: of vector: 4
last element: 20
map size: 6
Proline? 0
Proline? 1
</code></pre>
<h2 id="storage-classes">Storage classes</h2>
<p>Storage classes는 C++에서 변수나 함수가 메모리 내에서 어떻게 저장되고 접근되는지를 제어하는 데 사용된다. 다양한 저장 클래스는 변수 또는 함수의 범위(scope), 수명(lifetime), 초기화 및 접근 가능성(accessibility)을 결정한다.</p>
<p>여러 가지 저장 클래스가 있지만 일반적으로 다음과 같이 분류된다:</p>
<ul>
<li><strong>auto</strong>: C++11 이후 자동 형식 추론을 지원한다. 변수 선언 시 자료형을 명시하지 않고, 초기화된 값의 자료형을 기반으로 자동으로 결정한다.</li>
<li><strong>register</strong>: 레지스터 변수로 선언되며, 빠른 접근을 위해 레지스터에 저장되지만, 현대의 컴파일러는 레지스터 관리를 자동으로 수행하므로 거의 사용되지 않는다.</li>
<li><strong>static I</strong>: 함수 내에서 지역 변수로 사용할 경우, 함수 호출 이후에도 값이 유지된다. 또한 전역 변수로 선언될 경우, 다른 파일에서도 접근 가능하다.</li>
<li><strong>static II</strong>: 클래스 내에서 static 멤버로 사용될 경우, 클래스에 대한 멤버이며 객체에 속하지 않는다.</li>
<li><strong>extern</strong>: 다른 파일에 선언된 전역 변수를 현재 파일에서 사용할 때 사용된다.</li>
<li><strong>mutable</strong>: 클래스 객체의 멤버 변수를 변경 가능하게 만듭니다. 이는 const 멤버 함수 내에서도 해당 멤버 변수의 값을 변경할 수 있도록 한다.</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// Function declaration</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;

<span class="hljs-comment">// Global variable</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;

<span class="hljs-comment">// 자동 형식 추론을 사용한 변수 선언</span>
<span class="hljs-keyword">auto</span> x = <span class="hljs-number">4</span>;

<span class="hljs-comment">// 초기화 없이 선언할 수 없음</span>
<span class="hljs-comment">// 예시: auto x;</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// count 값을 감소시키면서 반복</span>
    <span class="hljs-keyword">while</span>(count--) { <span class="hljs-comment">// 두 번 감소!!</span>
        <span class="hljs-built_in">func</span>();
    }

    std::cout &lt;&lt; <span class="hljs-string">&quot;And x is &quot;</span> &lt;&lt; x &lt;&lt; std::endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// Function definition</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> </span>{
    <span class="hljs-comment">// 지역 static 변수</span>
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;
    i++;
    std::cout &lt;&lt; <span class="hljs-string">&quot;i is &quot;</span> &lt;&lt; i ;
    std::cout &lt;&lt; <span class="hljs-string">&quot; and count is &quot;</span> &lt;&lt; count &lt;&lt; std::endl;
}
</code></pre>
<pre><code>i is 6 and count is 9
i is 7 and count is 8
i is 8 and count is 7
i is 9 and count is 6
i is 10 and count is 5
i is 11 and count is 4
i is 12 and count is 3
i is 13 and count is 2
i is 14 and count is 1
i is 15 and count is 0
And x is 4
</code></pre>
<h2 id="templates">Templates</h2>
<p>템플릿(templates)은 C++에서 코드를 일반화하여 여러 자료형에 대해 동작할 수 있도록 하는 강력한 기능이다. 템플릿을 사용하면 클래스나 함수를 작성할 때 특정 자료형에 종속되지 않고, 여러 자료형에 대해 일반적으로 동작하도록 할 수 있다.</p>
<p>일반적으로 두가지 유형이 있다.:</p>
<ol>
<li>
<p>Class Templates</p>
<p>클래스 템플릿은 클래스를 정의할 때 사용되는 템플릿이다. 클래스 템플릿을 사용하면 특정 자료형에 대한 클래스를 생성할 때마다 클래스의 정의를 다시 작성할 필요가 없다. 대신, 템플릿을 사용하여 클래스를 정의하고, 특정 자료형에 대해 인스턴스화할 때 자료형을 지정한다.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> {
<span class="hljs-keyword">private</span>:
    T arr[<span class="hljs-number">100</span>];
    <span class="hljs-type">int</span> top;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Stack</span>() : <span class="hljs-built_in">top</span>(<span class="hljs-number">-1</span>) {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T val)</span> </span>{ arr[++top] = val; }
    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> arr[top--]; }
    <span class="hljs-function">T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> arr[top]; }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> top == <span class="hljs-number">-1</span>; }
};
</code></pre>
<p>템플릿을 이용하여 제네릭한 스택 클래스를 정의하는 예시이다.</p>
</li>
<li>
<p>Function Templates</p>
<p>함수 템플릿은 함수를 정의할 때 사용되는 템플릿이다. 함수 템플릿을 사용하면 특정 자료형에 대해 동일한 동작을 수행하는 함수를 여러 자료형에 대해 재사용할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>{
    T temp = a;
    a = b;
    b = temp;
}
</code></pre>
<p>다음은 템플릿을 사용하여 두 값을 교환하는 함수를 정의하는 예시이다.</p>
</li>
</ol>
<p>템플릿은 매우 유연하며 강력한 기능이지만, 사용법을 잘못하면 코드를 이해하거나 디버그하기 어려울 수 있다. 또한 템플릿을 사용할 때 특정 자료형에 대한 오버로딩된 함수가 생성될 수 있으므로 컴파일된 코드의 크기가 커질 수 있다.</p>
<h2 id="calling-function">Calling function</h2>
<p>함수 호출 방식에는 세 가지가 있다:</p>
<ol>
<li>
<p><strong>값에 의한 호출(Call by Value)</strong>:</p>
<ul>
<li>기본적으로 사용되는 방식이다.</li>
<li>호출할 때마다 매개변수로 전달되는 값의 <strong>복사본</strong>이 함수로 전달된다.</li>
<li>함수 내에서 매개변수의 값이 변경되더라도 호출된 곳의 변수에는 <strong>영향을 주지 않는다</strong>.</li>
</ul>
</li>
<li>
<p><strong>포인터에 의한 호출(Call by Pointer)</strong>:</p>
<ul>
<li>매개변수로 변수의 주소를 전달한다.</li>
<li>함수 내에서 매개변수를 통해 <strong>변수의 값을 변경할 수 있다</strong>.</li>
<li>함수가 호출될 때마다 변수의 주소가 전달되므로 함수 <strong>호출 시간이 더 오래 걸릴 수 있다</strong>.</li>
</ul>
</li>
<li>
<p><strong>참조에 의한 호출(Call by Reference)</strong>:</p>
<ul>
<li>C++에서만 사용할 수 있는 방식이다.</li>
<li>매개변수로 <strong>변수의 참조(레퍼런스)를 전달</strong>한다.</li>
<li>함수 내에서 매개변수를 통해 <strong>변수의 값을 변경할 수 있다</strong>.</li>
<li><strong>값에 의한 호출과 달리 함수 호출 시간이 더 짧다</strong>.</li>
<li>포인터에 의한 호출과 달리 <strong>주소 연산자(<code>&amp;</code>)를 사용할 필요가 없으므로 코드가 더 간결</strong>해진다.</li>
</ul>
</li>
<li>
<p><strong>기본 값이 있는 함수 인수(Default Arguments)</strong>:</p>
<ul>
<li>C++에서만 사용할 수 있는 기능이다.</li>
<li>함수의 매개변수에 기본 값을 할당할 수 있다. 함수 호출 시 해당 매개변수에 값을 전달하지 않으면 기본 값이 사용된다.</li>
<li>이를 통해 함수를 호출할 때 필요한 매개변수의 수를 줄일 수 있다.</li>
</ul>
</li>
</ol>
<p>이러한 함수 호출 방식은 각각의 상황에 따라 적합한 방법을 선택하여 사용해야 한다. 함수 호출 시에는 함수가 수행해야 할 작업과 매개변수로 전달되는 값의 변화 여부 등을 고려하여 적절한 호출 방식을 선택해야 한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// 함수 선언</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>)</span> </span>{
    <span class="hljs-type">int</span> result;
    result = a + b;
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 지역 변수 선언</span>
    <span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;
    <span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;
    <span class="hljs-type">int</span> result;

    <span class="hljs-comment">// 함수 호출하여 값들을 더한다.</span>
    result = <span class="hljs-built_in">sum</span>(a, b);
    cout &lt;&lt; <span class="hljs-string">&quot;Total value is : &quot;</span> &lt;&lt; result;

    <span class="hljs-comment">// 매개변수에 기본값이 있는 함수를 호출한다.</span>
    result = <span class="hljs-built_in">sum</span>(a);
    cout &lt;&lt; <span class="hljs-string">&quot; - Total value is : &quot;</span> &lt;&lt; result &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li><code>int sum(int a, int b = 20)</code>: 함수 sum은 매개변수 a와 b를 받는다. b의 기본값은 20으로 지정되어 있다.</li>
<li><code>result = sum(a, b);</code>: 함수 sum을 호출하여 a와 b를 인수로 전달한다. 이 때, b에 명시적으로 값이 전달되므로 기본값이 사용되지 않는다.</li>
<li><code>result = sum(a);</code>: 함수 sum을 호출하여 a만을 인수로 전달한다. 이 때, b의 기본값인 20이 사용된다.</li>
</ul>
<h2 id="math-functions">Math functions</h2>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// number definition:</span>
    <span class="hljs-type">short</span> s = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> i = <span class="hljs-number">-1000</span>;
    <span class="hljs-type">long</span> l = <span class="hljs-number">100000</span>;
    <span class="hljs-type">float</span> f = <span class="hljs-number">230.47</span>;
    <span class="hljs-type">double</span> d = <span class="hljs-number">200.374</span>;
    <span class="hljs-comment">// mathematical operations;</span>
    cout &lt;&lt; <span class="hljs-string">&quot;d is: &quot;</span> &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;sin(d) :&quot;</span> &lt;&lt; <span class="hljs-built_in">sin</span>(d) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;sin(f) :&quot;</span> &lt;&lt; <span class="hljs-built_in">sin</span>(f) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;abs(i) :&quot;</span> &lt;&lt; <span class="hljs-built_in">abs</span>(i) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;floor(d) :&quot;</span> &lt;&lt; <span class="hljs-built_in">floor</span>(d) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;sqrt(f) :&quot;</span> &lt;&lt; <span class="hljs-built_in">sqrt</span>(f) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;pow( d, 2) :&quot;</span> &lt;&lt; <span class="hljs-built_in">pow</span>(d, <span class="hljs-number">2</span>) &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code>d is: 200.374
sin(d) :-0.634939
sin(f) :-0.906
abs(i) :1000
floor(d) :200
sqrt(f) :15.1812
pow( d, 2) :40149.7
</code></pre>
<h2 id="random-number">random number</h2>
<ul>
<li>C++에서는 <code>rand()</code> 함수를 사용하여 랜덤한 정수를 생성할 수 있다. 그러나 이 함수는 유사 난수를 생성한다.</li>
<li>유사 난수를 생성하기 위해서는 먼저 <code>srand()</code> 함수를 호출하여 시드(seed) 값을 설정해야 한다.</li>
<li>시드 값은 랜덤 순서를 결정하는 초기 값으로, 동일한 시드 값이 주어지면 항상 동일한 랜덤 순서가 생성된다.</li>
<li>일반적으로 시드 값으로 현재 시간을 사용하여 매번 다른 랜덤 순서를 생성할 수 있다.</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// rand, srand 함수를 사용하기 위한 헤더</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span>   <span class="hljs-comment">// 현재 시간을 얻기 위한 헤더</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 현재 시간을 시드 값으로 사용</span>
    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));

    <span class="hljs-comment">// 0부터 RAND_MAX(32767) 사이의 랜덤 정수 생성</span>
    <span class="hljs-type">int</span> randomNumber = <span class="hljs-built_in">rand</span>();

    std::cout &lt;&lt; <span class="hljs-string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; std::endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h1 id="lecture-2">Lecture 2</h1>
<h2 id="inline-function">Inline function</h2>
<p>인라인 함수는 성능 최적화를 위해 사용되는 함수의 한 형태로, 함수 호출의 오버헤드를 줄이고자 하는 목적이다. 함수 호출의 오버헤드를 줄이기 위해 컴파일러에게 함수 호출 대신 함수의 코드 본문을 호출 위치에 직접 복사하도록 요청한다.</p>
<p>어떤 식이냐면, 함수를 호출하는 대신, 함수 본문을 호출 위치에 직접 삽입한다. 이는 특히 함수 호출이 빈번히 이루어지는 경우 성능을 향상할 수 있다. 즉, 빨라진다는 의미인데, 진짜 속도가 문제일 경우에만 사용이 권장된다. 함수를 호출할때 제어의 이동, 즉 점프가 발생하게 되는데, 이걸 줄여준다.</p>
<p>그러나, 이를 사용하게 되면 동일한 코드가 여러 위치에 복사되므로, 코드블럭의 크기가 증가할 수 있다. 따라서 매우 짧거나 간단한 함수들이 inline function 사용에 적합하다.</p>
<p>이 inline 함수는 컴파일러에게 &quot;야 대충 여기다가 꽂아넣으면 좋지않을까?&quot;하고 제안하는것과 마찬가지이다. 컴파일러가 판단하기에 적합하지 않으면, 사용하지 않을 수 있다. <code>#define</code>을 사용하는 매크로 보다는 인라인 함수를 사용하는게 더 권장된다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre>
<p>이런식으로 선언할 수 있으며, 본문에서 <code>add</code>함수를 사용할 경우 함수 본문이 호출된다.</p>
<h2 id="recursion-vs-iteration">Recursion vs Iteration</h2>
<p>Recursive function은 좀 간지나 보이지만, 비효율적인 경우가 많다. 함수 동작에 메모라이징과 캐싱이 사용되기 때문이다. 그에 비해 반복문은 대부분 좀 짜쳐보이지만 더 효율적인 경우가 많다.</p>
<h2 id="pointers-and-references">Pointers and References</h2>
<p>C++에서 포인터와 참조는 메모리 관리와 효율적인 데이터 처리를 위한 중요한 도구이다. C++에서 함수가 하나 이상의 값을 반환해야 하는 경우, 포인터와 참조를 사용하여 이를 해결할 수 있다. 이들은 함수 호출, 데이터 구조 처리, 메모리 직접 접근 등에 사용된다.</p>
<h3 id="how-to-return-more-than-one-valueitem">how to return more than one value/item?</h3>
<p>함수 인자를 reference를 사용해서 전달하는 경우, 함수 내부에서 값을 변경할 수 있다. 이는 파이썬같은곳에서 함수 내부의 변수가 local로 취급되어 변수를 반환하지 않을 시 변경되지 않는것과는 다르다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getValues</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> </span>{
    a = <span class="hljs-number">10</span>;
    b = <span class="hljs-number">20</span>;
}
</code></pre>
<p>이 경우, a와 b의 값이 실제로 변하게 된다. 이는 파이썬에서 처럼, 함수 실행시 값을 복사해오는게 아니라, reference를 통해 직접 값이 저장된 메모리에 접근이 가능하기 때문이다.</p>
<p>이를 통해, 여러 값을 한번에 처리할 수 있다. 이는 즉 여러값을 한번에 반환하는것과 다르지 않은 결과를 가져온다.</p>
<p>또한, 그저 변수가 아닌 데이터구조에 여러 변수를 욱여넣은 후 반환함으로써 여러 값을 한번에 반환할수도 있다.</p>
<pre><code class="language-cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; values = <span class="hljs-built_in">getValues</span>();
    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; values.first &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; values.second &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="call-by">Call by</h3>
<p>포인터 혹은 레퍼런스를 이용하여 함수를 호출할 수 있다. 보통은 value를 사용하여 함수를 호출한다. 이 경우, 함수 인자로 전달된 변수의 값을 복사하여 함수 내부로 전달하고, 함수 내부에서 인자의 값을 변경해도 원래의 변수에는 영향을 미치지 않는다. 이는 일반적으로 파이썬같은데서 사용되는 원리와 같다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{
    a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 원래의 변수에는 영향 없음</span>
}
</code></pre>
<p>그러나, 레퍼런스나 포인터로 함수를 호출하는 경우, 함수 인자로 전달된 변수 자체를 참조하여 함수 내부로 전달한다. 따라서, 함수 내부에서 인자의 값을 변경하면 원래의 변수에도 영향을 미치게 된다.</p>
<p>아래는 포인터를 사용한 예이다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> </span>{
    *a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 원래의 변수에 영향을 미침</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">foo</span>(&amp;x);
    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 5 출력</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>아래는 레퍼런스를 사용한 예시이다. 포인터 사용과는 달리 이는 C++에서만 가능하다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span> </span>{
    a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 원래의 변수에 영향을 미침</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">foo</span>(x);
    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="hljs-comment">// 5 출력</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>레퍼런스를 사용한 함수 호출이 가지는 장점이 무엇일까? 왜하는걸까? 이는 입력 변수를 변경할 필요가 있을때 유용할 수 있다. 그런데 이걸 자주쓰면 예상치 못한 부작용을 낳을 수 있으니 조심하자.</p>
<p>또한! 가장 중요한것. 큰 함수를 호출할때 큰 데이터 구조를 입력으로 사용한다면, 그리고 이걸 변수로 호출한다면, 이 큰 데이터구조가 모조리 복사되는 경우가 발생하는데 이는 비효율적이다. 이때 call by reference를 사용하면 데이터 스트럭쳐를 다 복사하지 않아도 개별 값에 접근하므로 성능이 향상된다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processLargeData</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;data)</span> </span>{
    <span class="hljs-comment">// 데이터 구조를 복사하지 않고 처리</span>
}
</code></pre>
<h4 id="pointer-and-reference">Pointer and Reference?</h4>
<p>이쯤에서 pointer와 reference에 대해 다시한번 짚고 넘어가자. 포인터는 변수의 메모리 주소를 저장하는 변수이다.</p>
<pre><code class="language-cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-type">int</span> *p = &amp;a; <span class="hljs-comment">// &#x27;p&#x27;는 &#x27;a&#x27;의 주소를 가리키는 포인터</span>
</code></pre>
<p>이는 포인터의 선언과 초기화이다.</p>
<p>cpp에서는 reference operator <code>*</code>와, address operator <code>&amp;</code>가 사용된다.</p>
<pre><code class="language-cpp"><span class="hljs-type">int</span> value = *p; <span class="hljs-comment">// &#x27;value&#x27;는 &#x27;a&#x27;의 값을 가짐 (10)</span>
</code></pre>
<p>즉, *p는 a의 주소값을 가지고 있는데, a의 위치에 직접 접근해서 a의 값을 가지고온다. <code>*p</code>가 포인터이기 때문에, <code>p</code>를 호출하면 a의 주소값이 나올것이다. 즉, 직접 출력을 해보면 <code>&amp;a==p</code>이고, <code>a==*p</code>이 나온다. 줜내 헷갈리쥬?</p>
<p>또한,</p>
<ul>
<li><strong>x가 만약 point이면, <code>*x</code>는 x의 주소값이다.</strong></li>
<li><strong>x가 일반 변수이면, <code>&amp;x</code>는 x의 주소값이다.</strong></li>
</ul>
<p><strong>reference variable</strong>이라는것도 존재하는데, 대충 아무 변수나 선언한뒤, 이 변수의 레퍼런스, 즉 주소값을 가리키는 변수를 선언하면 언제 어디서든 이 변수에 접근할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-type">int</span> &amp;ref = a;

std::cout &lt;&lt; ref &lt;&lt; std::endl; <span class="hljs-comment">// 참조 ref가 가리키는 변수의 값 출력 (10)</span>
ref = <span class="hljs-number">20</span>; <span class="hljs-comment">// 참조 ref가 가리키는 변수의 값을 20으로 변경</span>
std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="hljs-comment">// a의 값 출력 (20)</span>
</code></pre>
<p>이 레퍼런스는 한번 initialized 되면 다른 변수를 참조할 수 없다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">6</span>;
    <span class="hljs-type">int</span> y = <span class="hljs-number">7</span>;
    <span class="hljs-type">int</span> &amp;rx = x; <span class="hljs-comment">// rx는 x를 참조</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; rx=&quot;</span> &lt;&lt; rx &lt;&lt; <span class="hljs-string">&quot; y=&quot;</span> &lt;&lt; y &lt;&lt; std::endl;
    rx = y; <span class="hljs-comment">// x의 값을 y의 값으로 변경</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; rx=&quot;</span> &lt;&lt; rx &lt;&lt; <span class="hljs-string">&quot; y=&quot;</span> &lt;&lt; y &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code>x=6 rx=6 y=7
x=7 rx=7 y=7
</code></pre>
<p>여기선 rx만 바꿧는데, x가 따라서 바뀌었다. 이 관계는 바꿀 수 없다. 한번 rx와 x를 묶어놓으면, rx=y 이런걸 해도 안바뀐단 얘기다.</p>
<p>포인터는 C에서부터 도입된 것으로, 낡았다. C++에서도 포인터를 사용할 수 있긴 하지만, 웬만하면 reference만 사용하자. 또한, 작은 데이터를 다룰땐 굳이 불필요하니 큰 데이터를 사용할때만 사용하자.</p>
<h2 id="const-keyword">Const keyword</h2>
<p>C++에서 함수 인자를 <code>const</code> 키워드로 선언하면, 해당 인자의 값이 함수 내부에서 변경되지 않음을 보장할 수 있다. 상수로 선언하는것이다. 얘는 못바꿔용! 튜플같다. 이는 특히 큰 데이터 구조를 참조로 전달할 때 유용하다.</p>
<p>위에서 말햇듯, 레퍼런스와 포인터를 이용해 함수를 호출하는 것은 효율적이다. 그러나, 이것이 변수를 막 바꾸는 등 원치않는 부작용을 초래할 수 있기 때문에 조심해야한다고 했다. 이 때, 이 부작용을 막기위해 사용할 수 있는것이 바로 <code>const</code>이다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span> </span>{
    x = <span class="hljs-number">6</span>; <span class="hljs-comment">// 컴파일 에러: const 참조는 값을 변경할 수 없다.</span>
}
</code></pre>
<p><code>const</code>의 참조를 사용하여 큰 데이터를 처리하는 예시를 살펴보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;vec)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vec) {
        std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; std::endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; myVec = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">printVector</span>(myVec); <span class="hljs-comment">// vec는 const 참조로 전달됨</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>일단 큰 데이터를 처리할때, 참조를 이용해서 값을 직접 가져와놓고, 받을때 아예 const로 선언해서 혹시모를 불상사를 방지하는 것이다. 어차피 값만 가져오고 함수 내부에서 복사에서 쓰면 되잖아? 모든 데이터스트럭쳐를 싹 긁어오는것보다 훨씬 효율적이다. 또, 누가 실수로 혹은 고의로 내 코드를 족쳐놓는 것도 방지할 수 있다.</p>
<p>따라서, 내가 만약 reference를 이용해서 큰 데이터의 값을 받는다면, 반드시 const를 함께 사용하자.</p>
<h2 id="function-overloading">Function overloading</h2>
<p>함수 오버로딩은 동일한 이름을 가진 여러 함수를 생성할 수 있는 기능을 의미한다. 각 함수는 다른 매개변수 목록을 가지며, 함수 호출 시 전달된 인자의 유형과 개수에 따라 적절한 함수가 실행된다. 이는 함수 호출이 문맥에 따라 다른 작업을 수행할 수 있도록 한다.</p>
<p>간단히 말해서, 똑같은 이름의 함수를 여러개를 선언해 놓은뒤 사용하는 것이다. 가끔 parameter의 자료형때문에 오류가 발생하는 경우가 있는데, 이렇게 미리 오버로딩을 해놓으면 알아서 맞는걸 골라다 쓴다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// 정수 두 개를 더하는 함수</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// 실수 두 개를 더하는 함수</span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// 정수 세 개를 더하는 함수</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>{
    <span class="hljs-keyword">return</span> a + b + c;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;add(3, 4) = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; std::endl;           <span class="hljs-comment">// 정수형 add 호출</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;add(3.5, 2.7) = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">3.5</span>, <span class="hljs-number">2.7</span>) &lt;&lt; std::endl;   <span class="hljs-comment">// 실수형 add 호출</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;add(1, 2, 3) = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; std::endl;     <span class="hljs-comment">// 정수형 add(세 개) 호출</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</code></pre>
<p>사실 이건 C에서나 하는 방법이지, C++에선 그냥 <code>auto</code> 쓰면 된다.</p>
<h2 id="polymorphic-functions-with-templates">Polymorphic functions with templates</h2>
<p>여러 개의 타입 매개변수를 사용하는 템플릿 함수도 정의할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// 다중 타입 템플릿 함수 정의</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">multiply</span><span class="hljs-params">(T1 a, T2 b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a * b)</span> </span>{
    <span class="hljs-keyword">return</span> a * b;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;multiply(3, 4.5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">multiply</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4.5</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// int와 double 타입의 multiply 호출</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;multiply(2.5, 2) = &quot;</span> &lt;&lt; <span class="hljs-built_in">multiply</span>(<span class="hljs-number">2.5</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl;  <span class="hljs-comment">// double과 int 타입의 multiply 호출</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>대충 넘어가자. 나는 템플릿이 싫다.</p>
<h2 id="lambda-functions">Lambda Functions</h2>
<p>람다 함수는 익명 함수로, C++11부터 도입되었다. 파이썬에서도 람다함수를 찾아볼 수 있고, R에선 주로 <code>apply</code>함수가 이 역할을 한다.  람다 함수는 주로 간결한 일회성 함수를 작성할 때 사용되며, 코드의 가독성을 높이고 함수 객체를 쉽게 정의할 수 있게 한다.</p>
<p>예를 들어, 함수에 어떤 다른 함수를 써야하는데, 짧고 간단한데다가 한번밖에 안쓸 함수다. 이럴경우 간단히 람다함수를 이용할 수 있다.</p>
<p>람다함수는 다음과 같은 형식을 가진다.</p>
<pre><code>[캡처](매개변수) -&gt; 반환형 { 함수 본문 }
</code></pre>
<p><code>[]</code>를 이용해 선언한다. 저 브라켓 내부에는 변수가 들어갈 수 있는데, 외부 변수에 접근하기 위해 캡처를 사용한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> y = <span class="hljs-number">20</span>;

    <span class="hljs-comment">// 값에 의한 캡처</span>
    <span class="hljs-keyword">auto</span> addX = [x](<span class="hljs-type">int</span> a) -&gt; <span class="hljs-type">int</span> {
        <span class="hljs-keyword">return</span> a + x; <span class="hljs-comment">// x는 값으로 캡처됨</span>
    };

    <span class="hljs-comment">// 참조에 의한 캡처</span>
    <span class="hljs-keyword">auto</span> addY = [&amp;y](<span class="hljs-type">int</span> a) -&gt; <span class="hljs-type">int</span> {
        <span class="hljs-keyword">return</span> a + y; <span class="hljs-comment">// y는 참조로 캡처됨</span>
    };

    std::cout &lt;&lt; <span class="hljs-string">&quot;addX(5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">addX</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// addX(5) = 15 출력</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;addY(5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">addY</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// addY(5) = 25 출력</span>

    y = <span class="hljs-number">30</span>;
    std::cout &lt;&lt; <span class="hljs-string">&quot;addY(5) = &quot;</span> &lt;&lt; <span class="hljs-built_in">addY</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// addY(5) = 35 출력</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>캡처할 변수가 없는 경우 그냥 빈 <code>[]</code>만 사용해도 되며, 모든 외부변수를 값으로 캡쳐하려면 <code>=</code>를 넣고, 모든 외부 변수를 참조로 캡쳐하려면 <code>&amp;</code>를 넣는다. 물론 <code>[=,&amp;a]</code>와 같이 섞어쓰는것도 가능하다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;

    <span class="hljs-comment">// 모든 변수를 값으로 캡처</span>
    <span class="hljs-keyword">auto</span> lambda1 = [=]() {
        <span class="hljs-keyword">return</span> a + b + c;
    };

    <span class="hljs-comment">// 모든 변수를 참조로 캡처</span>
    <span class="hljs-keyword">auto</span> lambda2 = [&amp;]() {
        a = <span class="hljs-number">4</span>;
        <span class="hljs-keyword">return</span> a + b + c;
    };

    std::cout &lt;&lt; <span class="hljs-string">&quot;lambda1() = &quot;</span> &lt;&lt; <span class="hljs-built_in">lambda1</span>() &lt;&lt; std::endl; <span class="hljs-comment">// lambda1() = 6 출력</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;lambda2() = &quot;</span> &lt;&lt; <span class="hljs-built_in">lambda2</span>() &lt;&lt; std::endl; <span class="hljs-comment">// lambda2() = 9 출력</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>람다 함수는 표준 라이브러리와 함께 사용할 때 매우 유용하다. 특히, std::sort와 같은 알고리즘 함수에서 사용자 정의 비교 함수를 제공할 때 유용하다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};

    <span class="hljs-comment">// 람다 함수를 사용하여 벡터를 오름차순으로 정렬</span>
    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) {
        <span class="hljs-keyword">return</span> a &lt; b;
    });

    <span class="hljs-comment">// 정렬된 벡터 출력</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : vec) {
        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
    }
    std::cout &lt;&lt; std::endl; <span class="hljs-comment">// 1 2 3 5 8 출력</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="container">Container</h2>
<h3 id="array-1">Array</h3>
<p>배열은 C와 C++에서 기본적으로 제공되는 데이터 구조로, 동일한 타입의 데이터를 정해진 크기만큼 연속적으로 저장할 수 있는 구조이다. 사용 전에 미리 크기를 지정해야하고, 동일한 구조만 넣을 수 있기 때문에 제한이 많다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span> {
    <span class="hljs-comment">// 5행 2열의 배열 선언 및 초기화</span>
    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">2</span>] = { {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}, {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}, {<span class="hljs-number">2</span>,<span class="hljs-number">4</span>} };
    
    <span class="hljs-comment">// 각 배열 요소의 값을 출력</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) {
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;]: &quot;</span>;
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>C에서는 딱히 다른 선택지가 없어서 배열을 자주 사용해야한다. 그러나 C++에선 <code>vector</code>를 이용해 배열의 거의 모든 기능을 구현할 수 있으므로, 배열의 사용은 딱히 추천되지 않는다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix = {
        {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>},
        {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>},
        {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>}
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; matrix[i].<span class="hljs-built_in">size</span>(); ++j) {
            std::cout &lt;&lt; <span class="hljs-string">&quot;matrix[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;][&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;]: &quot;</span> &lt;&lt; matrix[i][j] &lt;&lt; std::endl;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>배열을 함수로 전달할수도 있는데, 이는 C에서와 C++에서 방법이 다르다.  C에서는 배열을 함수 인자로 전달할 때 배열의 크기도 함께 전달해야 하며, C++에서는 표준 라이브러리의 <code>std::vector</code>를 사용하여 더 안전하고 유연하게 배열을 처리할 수 있다.</p>
<p>C스타일은 다음과 같다.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
using namespace <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// C 스타일 배열과 크기를 전달받는 함수</span>
<span class="hljs-type">double</span> <span class="hljs-title function_">getAverage</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span> {
    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) {
        sum += arr[i];
    }
    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-type">double</span>&gt;(sum) / size;
}

</code></pre>
<p>C 표준을 따르기 때문에 기존 C 코드와 호환성이 높다. 그러나 배열 크기를 별도로 관리해야 하며, 포인터로 배열을 다루기 때문에 안전성이 떨어질 수 있다.</p>
<p>c++스타일은 다음과 같다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// C++ 스타일의 벡터를 전달받는 함수</span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getAverage</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr)</span> </span>{
    <span class="hljs-type">double</span> average = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : arr) {
        average += i;
    }
    <span class="hljs-keyword">return</span> average / arr.<span class="hljs-built_in">size</span>();
}
</code></pre>
<h3 id="which-container">Which container?</h3>
<p>C++ 표준 라이브러리는 다양한 데이터를 효율적으로 관리하고 처리하기 위해 여러 컨테이너를 제공한다.</p>
<h4 id="vector">Vector</h4>
<p><code>std::vector</code>는 동적 배열로, 크기가 자동으로 조정되는 배열이다.</p>
<ul>
<li>빠른 인덱스 접근 (O(1))</li>
<li>요소 삽입 및 삭제 (끝에서: O(1), 중간에서: O(n))</li>
<li>연속된 메모리 블록 사용</li>
</ul>
<p>주로,</p>
<ul>
<li>크기가 가변적인 배열이 필요할 때</li>
<li>인덱스를 통해 자주 접근해야 할 때</li>
<li>메모리 사용을 최적화하고 싶을 때</li>
</ul>
<p>사용한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// 요소 추가</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) {
        std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="map">map</h4>
<p><code>std::map</code>은 키-값 쌍을 저장하는 정렬된 연관 컨테이너이다.</p>
<ul>
<li>키를 기준으로 정렬됨</li>
<li>키를 통해 빠르게 요소를 검색 (O(log n))</li>
<li>중복 키를 허용하지 않음</li>
</ul>
<p>주로,</p>
<ul>
<li>키-값 쌍을 저장하고 정렬된 순서로 유지해야 할 때</li>
<li>빠른 검색이 필요할 때</li>
</ul>
<p>사용한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::map&lt;<span class="hljs-type">int</span>, std::string&gt; map;
    map[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;
    map[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;two&quot;</span>;
    map[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;three&quot;</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;pair : map) {
        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>C++은 여러 데이터 컨테이너를 제공하지만, 웬만하면 이 벡터와 맵으로 모두 표현이 가능하다. 더 쓴다면 뭐 리스트가 있겠다. 다른거 쓸필 요 없다.</p>
<p>또 벡터를 두개 겹쳐놓으면 매트릭스가 되기 때문에, 매트릭스도 뭐 r이나 매트랩에서 많이 써서 익숙하니 이걸 써도 된겠다.</p>
<h2 id="structure-and-classes">Structure and Classes</h2>
<h3 id="struct">Struct</h3>
<p>Struct는 서로 다른 종류의 데이터 항목을 결합하여 사용자 정의 데이터 타입을 만드는 것이다. C++에서 구조체는 기본적으로 모든 멤버 변수가 public으로 선언되며, 메서드가 포함되지 않는 경우가 많다. 이는 C++ 클래스와 유사하지만, 접근 제어에 차이가 있다.</p>
<p>예시를 보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Books</span> { <span class="hljs-comment">// struct 정의</span>
    <span class="hljs-type">char</span> title[<span class="hljs-number">50</span>]; <span class="hljs-comment">// 변수와 크기 선언</span>
    <span class="hljs-type">char</span> author[<span class="hljs-number">50</span>];
    <span class="hljs-type">char</span> subject[<span class="hljs-number">100</span>];
    <span class="hljs-type">int</span> book_id;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// struct 키워드는 선택 사항</span>
    Books Book1; <span class="hljs-comment">// Books 타입의 Book1 선언</span>
    Books Book2; <span class="hljs-comment">// Books 타입의 Book2 선언</span>

    <span class="hljs-comment">// Book1 정보 설정</span>
    <span class="hljs-built_in">strcpy</span>(Book1.title, <span class="hljs-string">&quot;Learn C++ Programming&quot;</span>); <span class="hljs-comment">// 내부 값에 변수 할당</span>
    <span class="hljs-built_in">strcpy</span>(Book1.author, <span class="hljs-string">&quot;Chand Miyan&quot;</span>);
    <span class="hljs-built_in">strcpy</span>(Book1.subject, <span class="hljs-string">&quot;C++ Programming&quot;</span>);
    Book1.book_id = <span class="hljs-number">6495407</span>;

    <span class="hljs-comment">// Book2 정보 설정</span>
    <span class="hljs-built_in">strcpy</span>(Book2.title, <span class="hljs-string">&quot;Telecom Billing&quot;</span>);
    <span class="hljs-built_in">strcpy</span>(Book2.author, <span class="hljs-string">&quot;Yakit Singha&quot;</span>);
    <span class="hljs-built_in">strcpy</span>(Book2.subject, <span class="hljs-string">&quot;Telecom&quot;</span>);
    Book2.book_id = <span class="hljs-number">6495700</span>;

    <span class="hljs-comment">// Book1 정보 출력</span>
    cout &lt;&lt; <span class="hljs-string">&quot;Book 1 title : &quot;</span> &lt;&lt; Book1.title &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book 1 author : &quot;</span> &lt;&lt; Book1.author &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book 1 subject : &quot;</span> &lt;&lt; Book1.subject &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book 1 id : &quot;</span> &lt;&lt; Book1.book_id &lt;&lt; endl;

    <span class="hljs-comment">// Book2 정보 출력</span>
    cout &lt;&lt; <span class="hljs-string">&quot;Book 2 title : &quot;</span> &lt;&lt; Book2.title &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book 2 author : &quot;</span> &lt;&lt; Book2.author &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book 2 subject : &quot;</span> &lt;&lt; Book2.subject &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book 2 id : &quot;</span> &lt;&lt; Book2.book_id &lt;&lt; endl;

    <span class="hljs-built_in">printBook</span>(Book1);
    <span class="hljs-built_in">printBook</span>(Book2);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBook</span><span class="hljs-params">(Books book)</span> </span>{
    cout &lt;&lt; <span class="hljs-string">&quot;Book title : &quot;</span> &lt;&lt; book.title &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book author : &quot;</span> &lt;&lt; book.author &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book subject : &quot;</span> &lt;&lt; book.subject &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Book id : &quot;</span> &lt;&lt; book.book_id &lt;&lt; endl;
}
</code></pre>
<p>struct와 class의 기본적인 차이는 접근 제어이다.</p>
<p>struct는 기본적으로 <code>public</code>으로 제어되고, 클래스는 기본적으로 <code>private</code>로 제어된다. 이에 따라 둘의 사용 목적도 갈리게 된다.</p>
<p>struct는 주로 데이터의 집합, 데이터 구조로 사용되는데 반해, class는 데이터와 해당 데이터를 처리하는 메서드를 함께 묶는다. 따라서 클래스는 상속, 다형성 등 객체 지향 프로그래밍의 모든 기능을 지원한다.</p>
<h3 id="class">Class</h3>
<p>클래스는 객체의 형태를 지정하기 위해 사용되며, 데이터 표현과 데이터를 조작하기 위한 메서드를 하나의 깔끔한 패키지로 결합한다. 클래스 내의 데이터와 함수는 클래스의 멤버라고 한다. 클래스는 객체 지향 프로그래밍의 핵심 개념으로, 데이터와 기능을 캡슐화하고 재사용성을 높이는 데 기여한다.</p>
<p>클래스 멤버는 접근 지정자에 따라 접근할 수 있는 범위가 달라진다.</p>
<p>C++에서는 <code>public</code>, <code>protected</code>, <code>private</code> 세 가지 접근 지정자를 사용할 수 있다.</p>
<p>클래스는 보통 <code>class</code>키워드로 선언되며, 클래스로 만들어진 인스턴스를 object라고 한다.</p>
<p>두가지 예시를 보도록 하자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> {
<span class="hljs-keyword">public</span>:
    std::string title;
    std::string author;
    std::string subject;
    <span class="hljs-type">int</span> book_id;

    <span class="hljs-comment">// 멤버 함수 선언</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBookInfo</span><span class="hljs-params">()</span></span>;
};

<span class="hljs-comment">// 멤버 함수 정의</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Books::printBookInfo</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;Title: &quot;</span> &lt;&lt; title &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Author: &quot;</span> &lt;&lt; author &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Subject: &quot;</span> &lt;&lt; subject &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Book ID: &quot;</span> &lt;&lt; book_id &lt;&lt; std::endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Books Book1; <span class="hljs-comment">// Books 클래스의 Book1 객체 생성</span>
    Books Book2; <span class="hljs-comment">// Books 클래스의 Book2 객체 생성</span>

    <span class="hljs-comment">// Book1 정보 설정</span>
    Book1.title = <span class="hljs-string">&quot;Learn C++ Programming&quot;</span>;
    Book1.author = <span class="hljs-string">&quot;Chand Miyan&quot;</span>;
    Book1.subject = <span class="hljs-string">&quot;C++ Programming&quot;</span>;
    Book1.book_id = <span class="hljs-number">6495407</span>;

    <span class="hljs-comment">// Book2 정보 설정</span>
    Book2.title = <span class="hljs-string">&quot;Telecom Billing&quot;</span>;
    Book2.author = <span class="hljs-string">&quot;Yakit Singha&quot;</span>;
    Book2.subject = <span class="hljs-string">&quot;Telecom&quot;</span>;
    Book2.book_id = <span class="hljs-number">6495700</span>;

    <span class="hljs-comment">// Book 정보 출력</span>
    Book1.<span class="hljs-built_in">printBookInfo</span>();
    Book2.<span class="hljs-built_in">printBookInfo</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>class 내에 선언된 함수나 변수에 접근하기 위해선 <code>.</code>를 사용한다.</p>
<p>다른 형식의 예시를 보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> {
<span class="hljs-keyword">public</span>:
    string title = <span class="hljs-string">&quot;&quot;</span>;
    string author = <span class="hljs-string">&quot;&quot;</span>;
    string subject = <span class="hljs-string">&quot;&quot;</span>;
    <span class="hljs-type">int</span> book_id = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBook</span><span class="hljs-params">()</span> </span>{
        cout &lt;&lt; <span class="hljs-string">&quot;Book title : &quot;</span> &lt;&lt; title &lt;&lt; endl;
        cout &lt;&lt; <span class="hljs-string">&quot;Book author : &quot;</span> &lt;&lt; author &lt;&lt; endl;
        cout &lt;&lt; <span class="hljs-string">&quot;Book subject : &quot;</span> &lt;&lt; subject &lt;&lt; endl;
        cout &lt;&lt; <span class="hljs-string">&quot;Book id : &quot;</span> &lt;&lt; book_id &lt;&lt; endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Books Book1; <span class="hljs-comment">// Book1 객체 생성</span>
    Books Book2; <span class="hljs-comment">// Book2 객체 생성</span>

    <span class="hljs-comment">// Book1 정보 설정</span>
    Book1.title = <span class="hljs-string">&quot;Learn C++ Programming&quot;</span>;
    Book1.author = <span class="hljs-string">&quot;Chand Miyan&quot;</span>;
    Book1.subject = <span class="hljs-string">&quot;C++ Programming&quot;</span>;
    Book1.book_id = <span class="hljs-number">6495407</span>;

    <span class="hljs-comment">// Book2 정보 설정</span>
    Book2.title = <span class="hljs-string">&quot;Telecom Billing&quot;</span>;
    Book2.author = <span class="hljs-string">&quot;Yakit Singha&quot;</span>;
    Book2.subject = <span class="hljs-string">&quot;Telecom&quot;</span>;
    Book2.book_id = <span class="hljs-number">6495700</span>;

    cout &lt;&lt; <span class="hljs-string">&quot;Class Example 2 ...\n&quot;</span>;
    Book1.<span class="hljs-built_in">printBook</span>();
    Book2.<span class="hljs-built_in">printBook</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>난 이게 더 좋은듯?</p>
<hr>
<p>클래스에 함수를 추가하려면 어떻게해야할까? 클래스의 멤버 함수는 클래스 정의 내에 프로토타입이나 정의를 가지고 있는 함수이다. 이러한 멤버 함수는 클래스의 객체에 대해 작동하며, 해당 객체의 모든 멤버에 접근할 수 있다.</p>
<p>ㅇ가보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 속성</span>
    string name;
    <span class="hljs-type">int</span> age;

    <span class="hljs-comment">// 생성자</span>
    <span class="hljs-built_in">Animal</span>(string n, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) {}

    <span class="hljs-comment">// 멤버 함수</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> </span>{
        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; is making a sound!&quot;</span> &lt;&lt; endl;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>{
        cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; endl;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">birthday</span><span class="hljs-params">()</span> </span>{
        age++;
        cout &lt;&lt; <span class="hljs-string">&quot;Happy Birthday, &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;! You are now &quot;</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot; years old.&quot;</span> &lt;&lt; endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Animal 객체 생성</span>
    <span class="hljs-function">Animal <span class="hljs-title">animal1</span><span class="hljs-params">(<span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-number">5</span>)</span></span>;
    <span class="hljs-function">Animal <span class="hljs-title">animal2</span><span class="hljs-params">(<span class="hljs-string">&quot;Cat&quot;</span>, <span class="hljs-number">3</span>)</span></span>;

    <span class="hljs-comment">// 객체의 정보 출력</span>
    animal1.<span class="hljs-built_in">printInfo</span>();
    animal2.<span class="hljs-built_in">printInfo</span>();

    <span class="hljs-comment">// 객체의 행동 호출</span>
    animal1.<span class="hljs-built_in">makeSound</span>();
    animal2.<span class="hljs-built_in">makeSound</span>();

    <span class="hljs-comment">// 생일 함수 호출</span>
    animal1.<span class="hljs-built_in">birthday</span>();
    animal2.<span class="hljs-built_in">birthday</span>();

    <span class="hljs-comment">// 다시 객체의 정보 출력</span>
    animal1.<span class="hljs-built_in">printInfo</span>();
    animal2.<span class="hljs-built_in">printInfo</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>어렵지 않다.</p>
<h4 id="getter-setter">Getter, Setter</h4>
<p>C++에서 <code>public</code> 변수는 일반적으로 권장되지 않는다. 대신, 모든 변수를 <code>private</code> 또는 <code>protected</code>로 선언하고, 해당 변수에 접근하거나 수정할 수 있는 getter 및 setter 함수를 제공하는 것이 좋은 방법이다.</p>
<ul>
<li><strong>Getter 함수</strong>: 클래스 멤버 변수의 값을 반환한다.</li>
<li><strong>Setter 함수</strong>: 클래스 멤버 변수의 값을 설정한다.</li>
</ul>
<p>이 둘을 추가하면 다음과 같은 형태가 된다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Setter 함수</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> </span>{
        <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">0</span>) {
            itsAge = age;
        } <span class="hljs-keyword">else</span> {
            cout &lt;&lt; <span class="hljs-string">&quot;Invalid age!&quot;</span> &lt;&lt; endl;
        }
    }

    <span class="hljs-comment">// Getter 함수</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> itsAge;
    }

    <span class="hljs-comment">// Getter 및 Setter 함수 추가</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;name)</span> </span>{
        itsName = name;
    }

    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> itsName;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSpecies</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;species)</span> </span>{
        itsSpecies = species;
    }

    <span class="hljs-function">string <span class="hljs-title">getSpecies</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        <span class="hljs-keyword">return</span> itsSpecies;
    }

<span class="hljs-keyword">protected</span>:
    <span class="hljs-type">int</span> itsAge = <span class="hljs-number">0</span>;
    string itsName;
    string itsSpecies;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Animal animal1;

    <span class="hljs-comment">// Setter 함수를 사용하여 속성 설정</span>
    animal1.<span class="hljs-built_in">setAge</span>(<span class="hljs-number">5</span>);
    animal1.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;Buddy&quot;</span>);
    animal1.<span class="hljs-built_in">setSpecies</span>(<span class="hljs-string">&quot;Dog&quot;</span>);

    <span class="hljs-comment">// Getter 함수를 사용하여 속성 출력</span>
    cout &lt;&lt; <span class="hljs-string">&quot;Animal Info:&quot;</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; animal1.<span class="hljs-built_in">getName</span>() &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Species: &quot;</span> &lt;&lt; animal1.<span class="hljs-built_in">getSpecies</span>() &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Age: &quot;</span> &lt;&lt; animal1.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="constructor">Constructor</h3>
<p>Constructor는 클래스의 특별한 멤버 함수로, 클래스의 새 객체가 생성될 때마다 실행된다. Constructor는 클래스와 정확히 같은 이름을 가지며, 반환형이 없으며, 멤버 변수의 초기 값을 설정하는 데 매우 유용하다.</p>
<ul>
<li><strong>클래스와 동일한 이름</strong>: 생성자는 클래스와 동일한 이름을 가져야 한다.</li>
<li><strong>반환형이 없음</strong>: 생성자는 반환형이 없으며, void조차도 사용하지 않다.</li>
<li><strong>자동 호출</strong>: 객체가 생성될 때 자동으로 호출된다.</li>
</ul>
<p>다음과 같은 종류가 있다:</p>
<ul>
<li><strong>Default Constructor</strong>: 매개변수가 없는 생성자.</li>
<li><strong>Parameterized Constructor</strong>: 매개변수를 받아 멤버 변수를 초기화하는 생성자.</li>
<li><strong>Copy Constructor</strong>: 다른 객체를 사용하여 새 객체를 초기화하는 생성자.</li>
</ul>
<p>이 constructor는 클래스 외부에서도 정의할 수 있다. 이는 클래스의 인터페이스와 구현을 분리할 수 있게 한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// 클래스 정의 (인터페이스)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 생성자 선언</span>
    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age);
    <span class="hljs-built_in">Animal</span>();
    
    <span class="hljs-comment">// 멤버 함수 선언</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>;
    
<span class="hljs-keyword">protected</span>:
    <span class="hljs-type">int</span> itsAge;
};

<span class="hljs-comment">// 멤버 함수 정의 (구현)</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Animal::getAge</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> itsAge;
}

<span class="hljs-comment">// 기본 생성자 정의</span>
Animal::<span class="hljs-built_in">Animal</span>() {
    cout &lt;&lt; <span class="hljs-string">&quot;simple animal creation ...&quot;</span> &lt;&lt; endl;
    itsAge = <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 매개변수가 있는 생성자 정의</span>
Animal::<span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age) {
    cout &lt;&lt; <span class="hljs-string">&quot;complex animal creation ...&quot;</span> &lt;&lt; endl;
    itsAge = age;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 기본 생성자를 사용한 객체 생성</span>
    Animal animal1;
    cout &lt;&lt; <span class="hljs-string">&quot;Animal1 age: &quot;</span> &lt;&lt; animal1.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;

    <span class="hljs-comment">// 매개변수가 있는 생성자를 사용한 객체 생성</span>
    <span class="hljs-function">Animal <span class="hljs-title">animal2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;
    cout &lt;&lt; <span class="hljs-string">&quot;Animal2 age: &quot;</span> &lt;&lt; animal2.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="initialization-list">Initialization list</h4>
<p>초기화 리스트는 C++에서 클래스 멤버 변수를 초기화하는 데 사용되는 특별한 구문이다. 초기화 리스트는 생성자의 본문이 실행되기 전에 멤버 변수의 초기화를 수행한다. 이를 통해 멤버 변수의 초기화와 할당을 분리하지 않고 한 번에 처리할 수 있다.</p>
<p>초기화 리스트는 콜론(:) 다음에 초기화할 멤버 변수와 그 초기값을 나열하는 방식으로 작성된다.</p>
<p>이 초기화 리스트 없이 생성자를 정의하면 다음과 같은 형태이다.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 생성자 1</span>
    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age) { itsAge = age; }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-type">int</span> itsAge = <span class="hljs-number">0</span>;
};
</code></pre>
<p>초기화 리스트를 사용하면?</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 생성자 1</span>
    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age) : <span class="hljs-built_in">itsAge</span>(age) { }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-type">int</span> itsAge = <span class="hljs-number">0</span>;
};
</code></pre>
<p>멤버 변수 여러개를 넣을수도 있다.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">ClassName</span>(매개변수 목록) : 멤버변수<span class="hljs-number">1</span>(초기값<span class="hljs-number">1</span>), 멤버변수<span class="hljs-number">2</span>(초기값<span class="hljs-number">2</span>), ... {
        <span class="hljs-comment">// 생성자 본문</span>
    }
};

</code></pre>
<p>이 초기화 리스트를 사용하면 여러 장점이 있다. 예를 들어, 초기화 리스트를 사용하면 멤버 변수가 객체 생성 시점에 바로 초기화된다. 이는 불필요한 기본 초기화와 재할당을 방지할 수 있어 더 효율적이다. 또한 초기화 리스트는 객체 생성 시점에 멤버 변수를 초기화하므로 불필요한 기본 초기화와 재할당을 방지할 수 있다.</p>
<p>이 초기화 리스트를 사용해야하는 상황이 두가지가 있다.</p>
<ol>
<li>상수 데이터 멤버 초기화 (Initialization of non-static const data members)</li>
</ol>
<p>상수 데이터 멤버는 객체가 생성된 후에는 값을 변경할 수 없기 때문에 초기화 리스트를 사용하여 생성 시에만 값을 설정할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// const 멤버 변수 &#x27;t&#x27; 초기화</span>
    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">t</span>(x) { }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        cout &lt;&lt; <span class="hljs-string">&quot;t: &quot;</span> &lt;&lt; t &lt;&lt; endl;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> t; <span class="hljs-comment">// const 멤버 변수</span>
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Test <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
    obj.<span class="hljs-built_in">print</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ol start="2">
<li>참조 멤버 초기화 (Initialization of reference members)</li>
</ol>
<p>참조 멤버는 선언 시 반드시 초기화되어야 하며, 이후에는 다른 객체를 참조하도록 변경할 수 없다. 따라서 참조 멤버도 초기화 리스트를 사용하여 초기화해야 한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 참조 멤버 변수 &#x27;ref&#x27; 초기화</span>
    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> &amp;x) : <span class="hljs-built_in">ref</span>(x) { }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
        cout &lt;&lt; <span class="hljs-string">&quot;ref: &quot;</span> &lt;&lt; ref &lt;&lt; endl;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> &amp;ref; <span class="hljs-comment">// 참조 멤버 변수</span>
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;
    <span class="hljs-function">Test <span class="hljs-title">obj</span><span class="hljs-params">(a)</span></span>;
    obj.<span class="hljs-built_in">print</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h1 id="lecture-3">Lecture 3</h1>
<h2 id="memorization">Memorization</h2>
<p>Memorization은 컴퓨터 프로그램에서 계산의 결과를 캐시에 저장하여 동일한 계산을 반복하지 않도록 하는 방법이다. 주로 재귀함수의 성능을 최적화하기 위해서 사용되며, 특히 다이나믹 프로그래밍에서 중요하게 사용된다. 특히, 피보나치에서 큰 성능 향상을 보인다. 이를 c++에서 적용하려면, 계산된 값을 저장할 array나 map을 사용해야한다.</p>
<p>예시로써 피보나치를 구현해보도록 하자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

std::vector&lt;<span class="hljs-type">int</span>&gt; memo;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> n;
    }
    <span class="hljs-comment">// 이미 계산된 값이 있으면 바로 반환</span>
    <span class="hljs-keyword">if</span> (memo[n] != <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">return</span> memo[n];
    }
    <span class="hljs-comment">// 계산된 값을 memo 배열에 저장</span>
    memo[n] = <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> memo[n];
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;
    <span class="hljs-comment">// memo 배열을 -1로 초기화 (아직 계산되지 않은 상태)</span>
    memo.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);
    std::cout &lt;&lt; <span class="hljs-string">&quot;Fibonacci of &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">fib</span>(n) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>여기서는 벡터를 이용해 array를 구현했고, 매 계산 후 값을 글로벌 변수 memo에 저장한 뒤, 매 재귀 호출마다 memo에 값이 있는지 확인하고 있으면 그걸 들고온다.</p>
<p>이런 메모라이제이션은 간단한 함수에서는 효과가 두드러지지 않을 수 있지만, 곱셈이나 덧셈이 큰숫자로 가게되면 계산 비용이 증가하게 되므로 메모라이제이션이 큰 효과를 나타낼 수 있다.</p>
<h2 id="destructor">Destructor</h2>
<p>이전 강의에서 Constructor에 대해 알아보았다. 그와 반대되는 개념인 Destructor는, <strong>클래스의 특수한 멤버 함수</strong>로써, 객체가 범위를 벗어날때나 <code>delete</code> expression이 그 클래스의 객체에 대한 <strong>포인터</strong>에 적용될 때 실행된다. <strong>Destructor는 클래스와 동일한 이름을 가지며,</strong> 앞에 <code>~</code>가 붙는다. <strong>Destructor는 값을 반환할 수 없으며 매개변수를 가질 수도 없다.</strong> 얘는 프로그램이 종료되기 전에 파일을 닫거나 메모리를해제하는 등 자원을 해제하는데 사용된다. 따라서 이는 자원 관리를 자동화하고 메모리 누수를 방지하는 중요한 역할을 한다.</p>
<p>예시를 통해 사용법을 알아보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>() {
        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor called!&quot;</span> &lt;&lt; std::endl;
    }

    ~<span class="hljs-built_in">MyClass</span>() {
        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor called!&quot;</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    MyClass obj; <span class="hljs-comment">// Constructor called!</span>
    <span class="hljs-comment">// 객체가 범위를 벗어나면 Destructor가 호출된다.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// Destructor called!</span>
}
</code></pre>
<p>여기서 객체가 범위를 벗어난다는 얘기는, 이 경우 <code>main</code>함수가 종료될 때 객체가 범위를 벗어나게 된다. 이때 destructor가 호출된다. destructor의 역할을 더 자세히 정리해보자.</p>
<ul>
<li>동적 메모리 해제: 객체가 동적으로 할당된 메모리를 해제할 때 Destructor를 사용한다.</li>
<li>파일 닫기: 파일 입출력 작업이 끝난 후 파일을 닫을 때 Destructor를 사용한다.</li>
<li>네트워크 연결 종료: 네트워크 연결을 종료할 때 Destructor를 사용한다.</li>
<li>기타 자원 해제: 기타 시스템 자원을 해제할 때 Destructor를 사용한다.</li>
</ul>
<p>동적 메모리를 해제하는 예시도 한번 살펴보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span>* data;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> size) {
        data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]; <span class="hljs-comment">// new는 새로운 동적 메모리를 할당하는데 사용된다. </span>
        std::cout &lt;&lt; <span class="hljs-string">&quot;Memory allocated!&quot;</span> &lt;&lt; std::endl;
    }

    ~<span class="hljs-built_in">MyClass</span>() {
        <span class="hljs-keyword">delete</span>[] data; <span class="hljs-comment">// array를 할당했기 때문에, delete[]를 사용</span>
        std::cout &lt;&lt; <span class="hljs-string">&quot;Memory deallocated!&quot;</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// Memory allocated!</span>
    <span class="hljs-comment">// 객체가 범위를 벗어나면 소멸자가 호출된다.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">// Memory deallocated!</span>
}
</code></pre>
<h2 id="static-members">Static members</h2>
<p>클래스의 멤버를 <code>static</code>으로 선언하게 되면, 그 클래스의 객체가 몇개 만들어지든 간에 <code>static member</code>는 <strong>단 하나의 복사본</strong>만 존재하게 된다. <strong>이 static member는 모든 객체에 의해 공유된다</strong>. 다른 초기화가 없으면, 첫번째 객체가 생성될 때 모든 static data는 0으로 초기화된다.</p>
<p><strong>static member는 반드시 클래스 내부에서 선언되어야 하며, 클래스 밖에서 초기화 되어야 한다.</strong> 클래스 내부에서 초기화 될 수 없으며, 클래스 외부에서 초기화할땐 범위 지정 연산자 <code>::</code>를 사용하여 다시 선언함으로써 초기화할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 생성자 1 선언</span>
    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age);
    <span class="hljs-comment">// 생성자 2 선언</span>
    <span class="hljs-built_in">Animal</span>();
    <span class="hljs-comment">// 소멸자 선언</span>
    ~<span class="hljs-built_in">Animal</span>();
    <span class="hljs-comment">// 멤버 함수 선언</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// static 멤버 변수</span>
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> animalCount;
    <span class="hljs-comment">// static 상수 멤버 변수</span>
    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> MAXANIMALS = <span class="hljs-number">10</span>;
    <span class="hljs-comment">// static member function, static vars에만 접근이 가능하다. </span>
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getAnimalCount</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> animalCount ;
    }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-type">int</span> itsAge = <span class="hljs-number">0</span>;
};

<span class="hljs-comment">// static 변수는 클래스 외부에서 초기화</span>
<span class="hljs-type">int</span> Animal::animalCount = <span class="hljs-number">0</span>;

<span class="hljs-comment">// 멤버 함수 정의</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Animal::getAge</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> itsAge;
}

<span class="hljs-comment">// 기본 생성자 정의, 클래스 외부에서 정의하는중이기 때문에, Animal::를 통해 내부에 접근</span>
Animal::<span class="hljs-built_in">Animal</span>() {
    animalCount += <span class="hljs-number">1</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;simple animal creation ...&quot;</span> &lt;&lt; endl;
}

<span class="hljs-comment">// 매개변수가 있는 생성자 정의</span>
Animal::<span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age) {
    animalCount += <span class="hljs-number">1</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;complex animal creation ...&quot;</span> &lt;&lt; endl;
    itsAge = age;
}

<span class="hljs-comment">// 소멸자 정의</span>
Animal::~<span class="hljs-built_in">Animal</span>() {
    cout &lt;&lt; <span class="hljs-string">&quot;destroy an animal (painless!)&quot;</span> &lt;&lt; endl;
    animalCount -= <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 외부 함수에서 static member function에 접근</span>
    Animal animal ;
    cout &lt;&lt; <span class="hljs-string">&quot;inside func we have &quot;</span> &lt;&lt; Animal::<span class="hljs-built_in">getAnimalCount</span>() &lt;&lt; <span class="hljs-string">&quot; animals &quot;</span> &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    Animal animal; <span class="hljs-comment">// 객체 생성</span>
    cout &lt;&lt;<span class="hljs-string">&quot;Animal 1&#x27;s age: &quot;</span> &lt;&lt;animal.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;
    <span class="hljs-function">Animal <span class="hljs-title">animal2</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>; <span class="hljs-comment">// 매개변수와 함께 객체 생성</span>
    cout &lt;&lt;<span class="hljs-string">&quot;Animal 2&#x27;s age: &quot;</span> &lt;&lt;animal2.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;
    <span class="hljs-built_in">func</span>();
    cout &lt;&lt; <span class="hljs-string">&quot;inside main we have &quot;</span> &lt;&lt; Animal::<span class="hljs-built_in">getAnimalCount</span>() &lt;&lt; <span class="hljs-string">&quot; animals &quot;</span> &lt;&lt; endl;
}

}
</code></pre>
<pre><code>simple animal creation ...
Animal 1's age: 0
complex animal creation ...
Animal 2's age: 12
simple animal creation ...
inside func we have 3 animals
destroy an animal (painless!)
inside main we have 2 animals
destroy an animal (painless!)
destroy an animal (painless!)
</code></pre>
<p>어떤 클래스 멤버 함수를 <code>static</code>으로 선언하게 되면, <strong>해당 함수는 클래스의 특정 객체와 독립적으로 작동한다.</strong> static 멤버 함수는 클래스의 객체가 존재하지 않더라도 호출할 수 있으며, static function은 클래스 이름과 <code>::</code>를 사용하여 접근한다. 예를 들어, <code>ClassName::staticFunction()</code>와 같은 형태이다. static member function은 static data member, 다른 static 멤버 함수 및 클래스 외부의 다른 함수에만 접근할 수 있다. 예를 들어, <code>ClassName::staticVar</code>와 같은 static 변수에만 접근이 가능하다.</p>
<h2 id="const-member-function">Const member function</h2>
<p>이미, 변경되지 않는 변수를 생성할 때 <code>const</code>키워드를 사용한 적이 있다. 클래스 내의 멤버 함수에서도 <code>const</code>를 사용할 수 있다. <strong>클래스 메서드를 <code>const</code>로 선언하면, 해당 메서드가 클래스의 어떤 멤버 변수 값도 변경하지 않을 것을 보장한다.</strong> 클래스 메서드를 const로 선언하려면, 매개변수를 둘러싸는 괄호 뒤에 <code>const</code> 키워드를 넣고 메서드 선언을 끝내는 세미콜론 앞에 위치시키면 된다.</p>
<p>위에서 봤던 animal 클래스의 예시에 이를 추가해보자.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age);      
    <span class="hljs-built_in">Animal</span>();             
    ~<span class="hljs-built_in">Animal</span>();            
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// Const 멤버 함수로 선언된 나이를 반환하는 함수, 뒤에 const를 붙여준다. </span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span></span>; <span class="hljs-comment">// 나이를 설정하는 함수, 그냥 멤버함수임.</span>
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> animalCount; 
<span class="hljs-keyword">protected</span>:
    <span class="hljs-type">int</span> itsAge = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 동물의 나이를 저장하는 변수</span>
};

<span class="hljs-type">int</span> Animal::animalCount = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Animal::getAge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-comment">// const를 같이 집어넣어준다.</span>
    <span class="hljs-keyword">return</span> itsAge;
}

<span class="hljs-comment">// setAge() 함수의 구현</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Animal::setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> </span>{
    itsAge = age;
}

Animal::<span class="hljs-built_in">Animal</span>() {
    animalCount += <span class="hljs-number">1</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;simple animal creation ...&quot;</span> &lt;&lt; endl;
}

Animal::<span class="hljs-built_in">Animal</span>(<span class="hljs-type">int</span> age) {
    animalCount += <span class="hljs-number">1</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;complex animal creation ...&quot;</span> &lt;&lt; endl;
    itsAge = age;
}

Animal::~<span class="hljs-built_in">Animal</span>() {
    cout &lt;&lt; <span class="hljs-string">&quot;destroy an animal (painless!)&quot;</span> &lt;&lt; endl;
    animalCount -= <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Animal animal;   <span class="hljs-comment">// 기본 생성자를 사용하여 Animal 객체 생성</span>
    cout &lt;&lt;<span class="hljs-string">&quot;Animal 1&#x27;s age: &quot;</span> &lt;&lt; animal.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;  <span class="hljs-comment">// 객체의 나이 출력</span>

    animal.<span class="hljs-built_in">setAge</span>(animal.<span class="hljs-built_in">getAge</span>() + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 나이를 1살 증가시킴</span>
    cout &lt;&lt;<span class="hljs-string">&quot;Animal 1&#x27;s age: &quot;</span> &lt;&lt; animal.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;  <span class="hljs-comment">// 증가된 나이 출력</span>

    cout &lt;&lt; <span class="hljs-string">&quot;inside main we have &quot;</span> &lt;&lt; Animal::animalCount &lt;&lt; <span class="hljs-string">&quot; animals &quot;</span> &lt;&lt; endl;  <span class="hljs-comment">// 전체 동물 수 출력</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code>simple animal creation ...
Animal 1's age: 0
Animal 1's age: 1
inside main we have 1 animals 
destroy an animal (painless!)
</code></pre>
<p>이 예시에선 딱히 잘 안보이긴 하는데, 왜냐면 const 함수인 <code>getAge</code>함수가 어차피 아무것도 안바꾸기 때문이다. 암튼, 이런식으로 사용할 수 있다.</p>
<h2 id="c-stdstring">C++ std::string</h2>
<p><code>std::string</code>은  C++ 표준 라이브러리에서 제공하는 문자열 처리를 위한 클래스이다. 문자를 처리하는 다양한 기능을 제공한다.</p>
<ul>
<li>
<p><strong>동적 크기 조정</strong>: <code>std::string</code>은 문자열의 길이를 동적으로 조정할 수 있다. 필요에 따라 문자열의 길이를 늘리거나 줄일 수 있으며, 메모리 관리를 자동으로 처리한다.</p>
</li>
<li>
<p><strong>문자열 저장</strong>: <code>std::string</code>은 문자들의 시퀀스를 저장하는 데 사용된다. 이 클래스를 사용하면 문자열의 추가, 제거, 검색 등의 작업을 쉽게 수행할 수 있다.</p>
</li>
<li>
<p><strong>유틸리티 함수</strong>: <code>std::string</code>은 다양한 유틸리티 함수를 제공하여 문자열 처리를 간편하게 만듭니다. 예를 들어, 길이 반환, 문자 찾기, 부분 문자열 추출, 문자열 합치기 등이 가능하다.</p>
</li>
<li>
<p><strong>문자열 비교</strong>: <code>std::string</code> 객체들은 문자열을 비교하는 다양한 방법을 제공한다. ==, !=, &lt;, &lt;=, &gt;, &gt;= 연산자들을 사용하여 문자열 간 비교가 가능하다.</p>
</li>
<li>
<p><strong>STL과의 통합</strong>: <code>std::string</code>은 C++ 표준 라이브러리(STL)의 일부이며, 다른 STL 컨테이너와 함께 사용할 수 있다. 예를 들어, 벡터(vector), 리스트(list) 등의 컨테이너에 <code>std::string</code>을 요소로 저장할 수 있다.</p>
</li>
<li>
<p><strong>간편한 초기화</strong>: <code>std::string</code> 객체는 다양한 방법으로 초기화할 수 있다. 문자열 리터럴을 직접 할당하거나, 다른 <code>std::string</code> 객체나 C 스타일 문자열로부터 초기화할 수 있다.</p>
</li>
</ul>
<p><code>std::string</code>과 <code>std::vector</code>를 사용하여 문자열 처리와 검색을 수행하는 예시를 보도록 하자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::string::size_type n;  <span class="hljs-comment">// 문자열의 인덱스를 저장할 변수</span>
    std::string <span class="hljs-type">const</span> s = <span class="hljs-string">&quot;t PEX Homework&quot;</span>;  <span class="hljs-comment">// 상수 문자열 s</span>
    std::vector&lt;std::string&gt; items = {  <span class="hljs-comment">// 문자열을 저장하는 벡터 items</span>
        <span class="hljs-string">&quot;t PEX-Homework&quot;</span>,
        <span class="hljs-string">&quot;t PEX-Quiz&quot;</span>,
        <span class="hljs-string">&quot;p PEX-Homework&quot;</span>
    };
    std::vector&lt;std::string&gt; choices = {<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>};  <span class="hljs-comment">// 선택지를 저장하는 벡터 choices</span>

    <span class="hljs-comment">// choices 벡터의 각 선택지에 대해 items 벡터를 순회</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : choices) { <span class="hljs-comment">// choices 내 각 벡터의 선택지를 순회</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : items) {
            <span class="hljs-comment">// item에서 선택지 c가 처음부터 시작하는 위치를 찾음</span>
            n = item.<span class="hljs-built_in">find</span>(c);
            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 선택지 c가 item의 첫 부분과 일치할 경우 출력</span>
                std::cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;-item: &quot;</span> &lt;&lt; item &lt;&lt; std::endl;
            }
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code>t-item: t PEX-Homework
t-item: t PEX-Quiz
p-item: p PEX-Homework
</code></pre>
<p>이 방법을 사용하려면, <code>#include &lt;string&gt;</code>와 <code>#include &lt;vector&gt;</code>가 필요하다. <code>std::string::size_type</code>은 문자열의 인덱스를 저장하는 데이터 타입이다. 아주 쓸모가 많다.</p>
<h2 id="input-output-and-file">Input, Output and File</h2>
<p>Input과 output에 사용되는 여러 함수들을 보자. 이에는 보통 <code>fstream</code>과 <code>iostream</code> 헤더파일이 필요하다.</p>
<p>iostream이란, 터미널과 interacting하는 것을 의미한다.</p>
<ul>
<li>
<p><code>std::cout</code>: 터미널(표준 출력)에 출력을 작성하는 데 사용된다. 일반적으로 사용자에게 정보를 표시하는 데에 쓰이다.</p>
<pre><code class="language-cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;안녕, 세상!&quot;</span> &lt;&lt; std::endl;
</code></pre>
</li>
<li>
<p><code>std::cin</code>: 터미널(표준 입력)로부터 입력을 읽어오는 데 사용된다. 사용자가 입력한 데이터를 받기 위해 사용된다.</p>
<pre><code class="language-cpp"><span class="hljs-type">int</span> number;
std::cout &lt;&lt; <span class="hljs-string">&quot;숫자를 입력하세요: &quot;</span>;
std::cin &gt;&gt; number;
</code></pre>
</li>
<li>
<p><code>std::cerr</code>: 오류 메시지를 즉시 오류 채널(표준 오류)에 쓰기 위해 사용된다. std::cout과 달리, std::cerr로 쓰인 메시지는 버퍼링되지 않고 즉시 표시된다.</p>
<pre><code class="language-cpp">std::cerr &lt;&lt; <span class="hljs-string">&quot;오류: 파일을 찾을 수 없다!&quot;</span> &lt;&lt; std::endl;
</code></pre>
</li>
<li>
<p><code>std::clog</code>: 오류 메시지를 오류 채널에 쓰지만, <code>std::cerr</code>와 달리 출력은 버퍼링된다. 이는 출력이 버퍼가 플러시되거나 프로그램이 종료될 때까지 지연될 수 있음을 의미한다.</p>
<pre><code class="language-cpp">std::clog &lt;&lt; <span class="hljs-string">&quot;경고: 메모리가 부족합니다!&quot;</span> &lt;&lt; std::endl;
</code></pre>
</li>
</ul>
<p>fstream은 파일에 대한 스트림 작업을 의미한다. C++의 <code>fstream</code> 라이브러리는 파일 입력 및 출력 작업을 다루는 클래스를 제공한다.</p>
<ul>
<li><code>ofstream</code>: 출력 파일 스트림을 나타내며, 파일에 데이터를 쓰기 위해 사용된다. 새 파일을 생성하거나 기존 파일을 덮어쓸 때 주로 사용된다.<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>

<span class="hljs-function">std::ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(<span class="hljs-string">&quot;output.txt&quot;</span>)</span></span>; <span class="hljs-comment">// 쓰기 위해 파일 생성/열기</span>
<span class="hljs-keyword">if</span> (outfile.<span class="hljs-built_in">is_open</span>()) {
    outfile &lt;&lt; <span class="hljs-string">&quot;이 내용이 파일에 쓰여집니다.\n&quot;</span>;
    outfile.<span class="hljs-built_in">close</span>();
}
</code></pre>
</li>
<li><code>ifstream</code>: 입력 파일 스트림을 나타내며, 파일에서 데이터를 읽기 위해 사용된다. 파일의 내용을 읽어야 할 때 사용된다.<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>

<span class="hljs-function">std::ifstream <span class="hljs-title">infile</span><span class="hljs-params">(<span class="hljs-string">&quot;input.txt&quot;</span>)</span></span>; <span class="hljs-comment">// 읽기 위해 파일 열기</span>
std::string line;
<span class="hljs-keyword">if</span> (infile.<span class="hljs-built_in">is_open</span>()) {
    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(infile, line)) {
        std::cout &lt;&lt; line &lt;&lt; std::endl; <span class="hljs-comment">// 각 줄을 콘솔에 출력</span>
    }
    infile.<span class="hljs-built_in">close</span>();
}
</code></pre>
</li>
</ul>
<h3 id="opening-a-file">Opening a file</h3>
<p>파일을 열기 위해서는 <code>&lt;fstream&gt;</code>를 포함해야하며, <code>std::ifstream</code>과 <code>std::ofstream</code>클래스를 사용하여 파일의 입출력을 처리한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>

std::ofstream ofs; <span class="hljs-comment">// 출력 파일 스트림 객체</span>
std::ifstream ifs; <span class="hljs-comment">// 입력 파일 스트림 객체</span>

<span class="hljs-comment">// 파일 열기</span>
ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, std::ios::in); <span class="hljs-comment">// 입력 파일 &quot;input.txt&quot;을 읽기 모드로 열기</span>
ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, std::ios::out); <span class="hljs-comment">// 출력 파일 &quot;output.txt&quot;을 쓰기 모드로 열기</span>

<span class="hljs-comment">// 파일 닫기</span>
ifs.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 입력 파일 닫기</span>
ofs.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 출력 파일 닫기</span>
</code></pre>
<h4 id="openmode">Openmode</h4>
<p><code>ios::openmode</code>는 파일을 열 때 사용할 여러 모드를 지정하는 열거형이다. 각각의 모드는 파일을 어떻게 열 것인지 결정한다.</p>
<ul>
<li><code>ios::app</code>: 파일의 끝에 데이터를 추가하는 모드이다. 이미 존재하는 파일에 쓸 때 유용하다.</li>
</ul>
<pre><code class="language-cpp">ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;log.txt&quot;</span>, std::ios::app); <span class="hljs-comment">// log.txt 파일을 추가 모드로 열기</span>
</code></pre>
<ul>
<li><code>ios::ate</code>: 파일을 출력용으로 열고 파일의 끝으로 커서를 이동시키는 모드이다. 즉, 파일의 마지막 위치에서 시작하여 데이터를 쓸 수 있다.</li>
</ul>
<pre><code class="language-cpp">ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, std::ios::out | std::ios::ate); <span class="hljs-comment">// data.txt 파일을 출력 및 끝에서 시작 모드로 열기</span>
</code></pre>
<ul>
<li><code>ios::in</code>: 파일을 읽기 모드로 연다.</li>
</ul>
<pre><code class="language-cpp">ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, std::ios::in); <span class="hljs-comment">// input.txt 파일을 읽기 모드로 열기</span>
</code></pre>
<ul>
<li><code>ios::out</code>: 파일을 쓰기 모드로 연다. 파일이 이미 존재할 경우, 이 모드는 기존 파일의 내용을 지우고 새로 씁니다.</li>
</ul>
<pre><code class="language-cpp">ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, std::ios::out); <span class="hljs-comment">// output.txt 파일을 쓰기 모드로 열기 (기존 내용 삭제됨)</span>
</code></pre>
<ul>
<li><code>ios::trunc</code>: 파일을 열기 전에 파일의 내용을 모두 삭제합니다. 주로 ios::out 모드와 함께 사용됩니다.</li>
</ul>
<pre><code class="language-cpp">ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, std::ios::out | std::ios::trunc); <span class="hljs-comment">// data.txt 파일을 쓰기 및 내용 초기화 모드로 열기</span>
</code></pre>
<p>아래는 사용 예시이다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 파일 쓰기 예시</span>
    <span class="hljs-function">std::ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(<span class="hljs-string">&quot;output.txt&quot;</span>, std::ios::out | std::ios::app)</span></span>;
    <span class="hljs-keyword">if</span> (outfile.<span class="hljs-built_in">is_open</span>()) {
        outfile &lt;&lt; <span class="hljs-string">&quot;Hello, &quot;</span>;
        outfile &lt;&lt; <span class="hljs-string">&quot;World!&quot;</span> &lt;&lt; std::endl;
        outfile.<span class="hljs-built_in">close</span>();
    } <span class="hljs-keyword">else</span> {
        std::cerr &lt;&lt; <span class="hljs-string">&quot;파일을 열 수 없습니다!&quot;</span> &lt;&lt; std::endl;
    }

    <span class="hljs-comment">// 파일 읽기 예시</span>
    <span class="hljs-function">std::ifstream <span class="hljs-title">infile</span><span class="hljs-params">(<span class="hljs-string">&quot;input.txt&quot;</span>, std::ios::in)</span></span>;
    std::string line;
    <span class="hljs-keyword">if</span> (infile.<span class="hljs-built_in">is_open</span>()) {
        <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(infile, line)) {
            std::cout &lt;&lt; line &lt;&lt; std::endl;
        }
        infile.<span class="hljs-built_in">close</span>();
    } <span class="hljs-keyword">else</span> {
        std::cerr &lt;&lt; <span class="hljs-string">&quot;파일을 열 수 없습니다!&quot;</span> &lt;&lt; std::endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><code>std::ios::out | std::ios::app</code>는 파일을 열 때 사용하는 모드 플래그이다. 이것은 OR 연산자를 사용, 두가지 플래그를 결합하여 파일을 열 때 동작을 지정한다.</p>
<p>이를 통해, 파일을 쓰기 모드로 열되, 파일의 끝에 데이터를 추가할 수 있는 상태로 연다.</p>
<h3 id="stringstream">Stringstream</h3>
<p>스트림이라는 단어가 계속 나온다. 스트림이란 뭘까? 스트림(stream)은 데이터가 흐르는 통로라고 생각할 수 있다. C++에서 스트림은 입출력을 쉽게 다루기 위한 추상화된 개념이다. 주로 데이터를 읽어오거나 출력하는 작업에서 사용되며, 파일, 터미널, 메모리 등 다양한 소스와 대상으로 데이터를 전송할 수 있다. <code>&lt;&lt;</code>나 <code>&gt;&gt;</code> 또한 스트림 연산자이다.</p>
<p>스트림은 내부적으로 버퍼를 사용하여 데이터를 일시적으로 저장하고, 효율적인 입출력을 위해 데이터를 묶어서 처리한다. 이 버퍼링은 입출력의 성능을 향상시키고, 프로그램의 실행 속도를 개선하는데 중요한 역할을 한다.</p>
<p><code>std::stringstream</code>은 문자열을 스트림으로 다룰 수 있게 해준다. 이는 <code>&lt;sstream&gt;</code> 헤더파일에서 제공된다. <code>std::stringstream</code> 객체는 문자열을 스트림처럼 다룰 수 있어서, 문자열에서 데이터를 읽어오거나 데이터를 문자열로 변환하는 데 쓰인다. 주로 입력 문자열을 파싱하거나, 다양한 형식의 데이터를 문자열로 만드는 작업에 활용된다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span> <span class="hljs-comment">// stringstream을 사용하기 위한 헤더 파일</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::string S = <span class="hljs-string">&quot;Hello C++ World!&quot;</span>;
    <span class="hljs-function">std::stringstream <span class="hljs-title">X</span><span class="hljs-params">(S)</span></span>; <span class="hljs-comment">// 문자열 S를 stringstream X 객체에 연결</span>

    std::string T; <span class="hljs-comment">//  각 단어를 저장할 변수 T를 준비</span>
    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(X, T, <span class="hljs-string">&#x27; &#x27;</span>)) { <span class="hljs-comment">// X에서 공백(&#x27; &#x27;)을 기준으로 문자열을 읽어 T에 저장</span>
        std::cout &lt;&lt; T &lt;&lt; std::endl; <span class="hljs-comment">// 각 단어를 출력</span>
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code>Hello
C++
World!
</code></pre>
<h3 id="filesystem">Filesystem</h3>
<p>C++17에서 도입된 Filesystem 라이브러리는 Boost 라이브러리에서 가져온 핵심 부분들을 포함한다. 이 라이브러리는 파일 및 디렉터리 경로와 관련된 작업을 수행하며, 다음과 같은 주요 구성 요소들이 있다.</p>
<ul>
<li><strong>path object</strong>: 파일 또는 디렉터리의 경로를 나타내는 객체이다.</li>
<li><strong>directory_entry</strong>: 디렉터리의 각 항목(파일 또는 하위 디렉터리)에 대한 정보를 제공하는 객체이다.</li>
<li><strong>directory iterators</strong>: 디렉터리 내의 파일 및 디렉터리를 반복적으로 탐색할 수 있는 반복자이다.</li>
<li><strong>supportive functions</strong>: 경로에 관한 정보, 파일 조작(복사, 이동, 생성 등), 파일 속성, 시간, 크기 등 다양한 작업을 수행할 수 있는 보조 함수들을 포함합니다.</li>
</ul>
<p>예시 코드를 보자.</p>
<p>이 코드는 이전 버전의 컴파일러에 대한 호환성을 고려하여, 사용 가능한 파일시스템 지원에 따라 <filesystem> 또는 &lt;experimental/filesystem&gt; 헤더를 포함하고 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;version&gt;</span></span>

<span class="hljs-comment">// 이전 버전의 컴파일러에서 파일시스템 라이브러리 지원 확인</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cpp_lib_filesystem</span>
    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>
    <span class="hljs-keyword">namespace</span> fs = std::filesystem;
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> __cpp_lib_experimental_filesystem</span>
    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;experimental/filesystem&gt;</span></span>
    <span class="hljs-keyword">namespace</span> fs = std::experimental::filesystem;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
    <span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;no filesystem support =&#x27;(&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;current_path:\n&quot;</span> &lt;&lt; fs::<span class="hljs-built_in">current_path</span>() &lt;&lt; <span class="hljs-string">&quot;\nExists Makefile?: &quot;</span> &lt;&lt; fs::<span class="hljs-built_in">exists</span>(<span class="hljs-string">&quot;../Makefile&quot;</span>) &lt;&lt; std::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li>
<p><code>current_path()</code>: <code>fs::current_path()</code> 함수는 현재 작업 디렉터리의 경로를 반환한다.</p>
</li>
<li>
<p><code>exists()</code>: <code>fs::exists(&quot;../Makefile&quot;)</code> 함수는 지정된 경로의 파일이나 디렉터리가 존재하는지 여부를 검사한다.</p>
</li>
</ul>
<h4 id="preprocessor">Preprocessor</h4>
<p>위에서 나온 코드중에 처음보는 이상한것들이 있다. 이들은 preprocessor라는 것으로, 컴파일 이전 단계에서 실행되며 코드의 특정 부분을 컴파일 전에 처리하는데 사용된다. 차근차근 살펴보자.</p>
<p><code>#ifdef</code>은 &quot;if defined&quot;의 약자로, 지정된 심볼이 정의되어있는지 여부를 확인한다. 이 뒤에 따라온 <code>__cpp_lib_filesystem</code>은 C++ 표준 라이브러리에 파일시스템 지원이 포함되어 있는지 여부를 확인하는 매크로이다.  C++17부터 표준 라이브러리에 파일시스템이 포함되었으므로, 이 매크로는 C++17 이상에서는 정의된다. 나머지 <code>#elif</code>와 <code>else</code> 또한 기존과 동일한 역할을 수행한다. preprocessor의 경우, <code>#endif</code>를 통해 조건문을 종료해주어야 한다.</p>
<p><code>#error</code>는 뭘까? <strong>preprocessor가 처리를 하다가 이 지시문을 만나면 컴파일을 중단하고 오류메세지를 출력한다.</strong></p>
<p><code>namespace fs = std::filesystem;</code>는 파일시스템 라이브러리를 사용하기 위해 적절한 네임스페이스를 정의한다. C++17 이상에서는 <code>std::filesystem</code>를 사용하고, 그 이전 버전에서는 <code>std::experimental::filesystem</code>를 사용한다.</p>
<h3 id="traversing-a-directory">Traversing a directory</h3>
<p>Traversing a directory란 파일 시스템에서 특정 디렉터리 안에 있는 파일과 디렉터리들을 순차적으로 접근하고 조사하는 과정을 말한다. 이 과정은 주어진 디렉터리 안의 모든 파일과 하위 디렉터리를 찾고, 각각에 대해 필요한 작업을 수행하는 것을 포함한다. 위에서 언급한 <code>Filesystem</code> 라이브러리를 사용하여 제어가 가능하다.</p>
<p>예시를 보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span>

<span class="hljs-keyword">namespace</span> fs = std::filesystem;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayDirTree</span><span class="hljs-params">(<span class="hljs-type">const</span> fs::path&amp; pathToShow, <span class="hljs-type">int</span> level)</span> </span>{
    <span class="hljs-keyword">if</span> (fs::<span class="hljs-built_in">exists</span>(pathToShow) &amp;&amp; fs::<span class="hljs-built_in">is_directory</span>(pathToShow)) { <span class="hljs-comment">// 1</span>
        <span class="hljs-keyword">auto</span> lead = std::<span class="hljs-built_in">string</span>(level * <span class="hljs-number">3</span>, <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">// 들여쓰기 공백 계산</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : fs::<span class="hljs-built_in">directory_iterator</span>(pathToShow)) { <span class="hljs-comment">// 2</span>
            <span class="hljs-keyword">auto</span> filename = entry.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">filename</span>(); <span class="hljs-comment">// 항목의 파일명 획득</span>
            <span class="hljs-keyword">if</span> (fs::<span class="hljs-built_in">is_directory</span>(entry.<span class="hljs-built_in">status</span>())) { <span class="hljs-comment">// 3</span>
                std::cout &lt;&lt; lead &lt;&lt; <span class="hljs-string">&quot;[+] &quot;</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 디렉터리인 경우 [+] 표시</span>
                <span class="hljs-built_in">DisplayDirTree</span>(entry, level + <span class="hljs-number">1</span>); <span class="hljs-comment">// 재귀적으로 하위 디렉터리 순회</span>
                std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fs::<span class="hljs-built_in">is_regular_file</span>(entry.<span class="hljs-built_in">status</span>())) { <span class="hljs-comment">// 4</span>
                std::cout &lt;&lt; lead &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 파일인 경우 출력</span>
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 5</span>
                std::cout &lt;&lt; lead &lt;&lt; <span class="hljs-string">&quot; [?]&quot;</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 기타 상황 처리</span>
            }
        }
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;Directory test:\n&quot;</span>;
    <span class="hljs-built_in">DisplayDirTree</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// &quot;test&quot; 디렉터리 순회</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ol>
<li><code>fs::exists(pathToShow) &amp;&amp; fs::is_directory(pathToShow)</code>는, 먼저 시작 디렉터리가 존재하는지 확인하고, 원하는 디렉토리인지 확인한다.</li>
<li><code>fs::directory_iterator(pathToShow)</code>를 이용하여 디렉토리 내의 각 항목을 반복적으로 처리한다. <code>const auto&amp;</code>는 <code>entry</code>가 <code>fs::directory_entry</code> 객체에 대한 const 참조임을 나타낸다. 이는 <code>entry</code>를 통해 디렉터리 항목의 내용을 읽고 수정하지 않음을 보장한다.</li>
<li><code>fs::is_directory(entry.status())</code>를 사용하여 디렉터리인지 확인하고, 디렉터리라면 [+]를 추가하여 출력한다.</li>
<li><code>fs::is_regular_file(entry.status())</code>를 사용하여 일반 파일인지 확인하고, 일반 파일이라면 파일명을 출력한다.</li>
<li>기타 상황에서는 [?]를 추가하여 처리한다.</li>
</ol>
<p>예를 들어, 만약 다음과 같은 구조가 있다면,</p>
<pre><code>test/
├── dir1/
│   ├── file1.txt
│   └── file2.txt
├── dir2/
│   ├── subdir/
│   │   └── file3.txt
│   └── file4.txt
└── file5.txt
</code></pre>
<p>다음과 같이 출력한다.</p>
<pre><code>Directory test:
[+] dir1
   file1.txt
   file2.txt

[+] dir2
   file4.txt

   [+] subdir
      file3.txt

file5.txt
</code></pre>
<h3 id="get-home-directory">Get home directory</h3>
<p>홈 디렉토리를 반환하는 함수의 예시를 한번 보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>   <span class="hljs-comment">// 표준 입력 및 출력을 위한 헤더 파일</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>    <span class="hljs-comment">// C 표준 라이브러리의 일부로, getenv 함수를 사용하기 위한 헤더 파일</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>     <span class="hljs-comment">// 문자열 관리를 위한 표준 라이브러리</span></span>

<span class="hljs-keyword">namespace</span> pex {
    <span class="hljs-function">std::string <span class="hljs-title">get_home_directory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// get home directory Unix</span>
        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* homeDir = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;HOME&quot;</span>);  <span class="hljs-comment">// Unix 시스템에서 환경 변수 HOME을 통해 홈 디렉터리 경로 가져오기</span>
        <span class="hljs-comment">// Get home directory on Windows (untested)</span>
        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* userProfile = <span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;USERPROFILE&quot;</span>);  <span class="hljs-comment">// Windows 시스템에서 환경 변수 USERPROFILE을 통해 홈 디렉터리 경로 가져오기</span>
        
        std::string result = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">// 결과를 저장할 빈 문자열 초기화</span>
        
        <span class="hljs-keyword">if</span> (homeDir != <span class="hljs-literal">nullptr</span>) {
            result = homeDir;  <span class="hljs-comment">// 환경 변수 HOME이 존재하면 그 값을 result에 할당</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userProfile != <span class="hljs-literal">nullptr</span>) {
            result = userProfile;  <span class="hljs-comment">// 환경 변수 USERPROFILE이 존재하면 그 값을 result에 할당</span>
        }
        
        <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">// 홈 디렉터리 경로 반환</span>
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;PEX Home: &quot;</span> &lt;&lt; pex::<span class="hljs-built_in">get_home_directory</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// PEX Home: 와 함께 홈 디렉터리 경로 출력</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 프로그램 정상 종료</span>
}
</code></pre>
<h3 id="formatted-output">Formatted Output</h3>
<p>Formatted Output은 프로그래밍에서 특정 형식에 맞추어 데이터를 문자열로 변환하여 화면에 출력하는 과정을 말한다. C++에서는 여러 가지 방법으로 포맷팅된 출력을 구현할 수 있다.</p>
<ol>
<li>
<p><strong><code>std::cout</code>을 이용한 포맷팅</strong></p>
<ul>
<li>C++의 기본 출력 스트림인 <code>std::cout</code>을 사용하여 데이터를 화면에 출력할 수 있다.</li>
<li><code>std::setw</code>, <code>std::setprecision</code>, <code>std::fixed</code> 등의 맨니퓰레이터(manipulator) 함수들을 이용하여 출력 포맷을 지정할 수 있다.<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">double</span> number = <span class="hljs-number">3.141592653589793</span>;
    std::cout &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>) &lt;&lt; std::fixed &lt;&lt; number &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>C 스타일의 <code>printf</code> 함수</strong></p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> number = <span class="hljs-number">42</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The answer is %d.\n&quot;</span>, number);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
<li>
<p><strong>현대적인 방법: <code>fmt</code> 라이브러리</strong></p>
<ul>
<li>
<p>C++11 이상에서는 <code>fmt</code> 라이브러리를 사용하여 더욱 간편하고 강력한 포맷팅 기능을 제공받을 수 있다.</p>
</li>
<li>
<p>Python의 포맷 문자열과 유사한 형태로 포맷팅을 지원하며, 타입에 맞추어 자동으로 변환한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fmt/core.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> number = <span class="hljs-number">42</span>;
    std::string s = fmt::format(<span class="hljs-string">&quot;The answer is {}.\n&quot;</span>, number);
    fmt::<span class="hljs-built_in">print</span>(s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
<li>
<p><code>{}</code>를 사용하여 변수를 삽입하고,<code> fmt::format</code> 함수를 통해 포맷 문자열을 생성한다.</p>
</li>
<li>
<p><code>fmt::print</code> 함수를 사용하여 포맷 문자열을 출력한다.</p>
</li>
</ul>
</li>
<li>
<p><strong>C++20에서의 표준 포맷팅</strong></p>
<ul>
<li>
<p>C++20에서는 std::format 함수가 추가되어, 포맷 문자열의 표준 기능이 제공된다. 파이썬의 f-string과 유사한 형태.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;format&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> number = <span class="hljs-number">42</span>;
    std::string s = std::format(<span class="hljs-string">&quot;The answer is {}.\n&quot;</span>, number);
    std::cout &lt;&lt; s;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</li>
<li>
<p><code>std::format</code> 함수를 사용하여 포맷 문자열을 생성하고, <code>std::cout</code>을 통해 출력한다.</p>
</li>
</ul>
</li>
</ol>
<h1 id="lecture-4">Lecture 4</h1>
<h2 id="inheritance">Inheritance</h2>
<p>C++ 또한 객체지향 프로그래밍을 지원한다. 따라서 inheritance를 사용할 수 있다.</p>
<p>Base Class와 Derived Class로 나뉘게 되는데, 아래 예시를 통해 알아보자.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-type">int</span> x;
    <span class="hljs-keyword">protected</span>:
        <span class="hljs-type">int</span> y;
    <span class="hljs-keyword">private</span>:
        <span class="hljs-type">int</span> z;
    };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A {
<span class="hljs-comment">// x is public</span>
<span class="hljs-comment">// y is protected</span>
<span class="hljs-comment">// z is not accessible</span>
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">protected</span> A {
<span class="hljs-comment">// x is protected</span>
<span class="hljs-comment">// y is protected</span>
<span class="hljs-comment">// z is not accessible</span>
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">private</span> A {
<span class="hljs-comment">// &#x27;private&#x27; is default</span>
<span class="hljs-comment">// for classes</span>
<span class="hljs-comment">// x is private</span>
<span class="hljs-comment">// y is private</span>
<span class="hljs-comment">// z is not accessible</span>
};

</code></pre>
<pre><code class="language-cpp">DerivedClass : <span class="hljs-keyword">public</span> BaseClass {
<span class="hljs-comment">// derived class has the same interface as the</span>
<span class="hljs-comment">// BaseClass, it can implement more methods.</span>
};
DerivedClass : <span class="hljs-keyword">protected</span> BaseClass {
<span class="hljs-comment">// class inheriting from DerivedClass has access to</span>
<span class="hljs-comment">// all protected/public (now protected) methods of BaseClass</span>
<span class="hljs-comment">// objects created from derived class have no!</span>
<span class="hljs-comment">// access to methods and properties in BaseClass</span>
};
DerivedClass : <span class="hljs-keyword">private</span> BaseClass {
<span class="hljs-comment">// class inheriting from DerivedClass has access to</span>
<span class="hljs-comment">// all protected/public (now private) methods of BaseClass</span>
<span class="hljs-comment">// object created from derived class have no!</span>
<span class="hljs-comment">// access to methods and properties in BaseClass</span>
};

</code></pre>
<p>C++에서는 Base Class를 public, protected 또는 private로 선언함으로써 이게 어떻게 inherited 될 것인지 컨트롤 할 수 있다.</p>
<p>Derived Class의 객체는 Base 클래스의 public으로 선언된 모든것들에 접근이 가능하다. 만약 베이스 클래스에서 protected로 선언된 것들이 있다면, derived class의 객체는 일단 접근이 가능하다. 사용은 가능하단 뜻이다. 그러나, 외부 코드나 베이스 클래스의 보호된 멤버에는 직접 접근할 수 없다. 즉, derived 클래스의 객체는 그 객체가 속한 클래스 내에서만 베이스 클래스의 protected member를 사용할 수 있다.</p>
<p>private 멤버의 경우, 애초에 상속이 불가능하며, 클래스 외부에서 접근할 수 없다.</p>
<p>Animal 클래스의 더 자세한 예시를 보자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;Run, run, run!\n&quot;</span>; }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;Eating generic food!\n&quot;</span>; }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">meow</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;Meow, meow!\n&quot;</span>;
    }
};
<span class="hljs-comment">// we have run automatically as we used: public Animal</span>
<span class="hljs-comment">// 자동으로 부모클래스의 run과 eat 함수를 가진다. </span>
<span class="hljs-comment">// 새로운 함수를 추가할 수 있다.</span>

<span class="hljs-comment">// private inheritance is the default</span>
<span class="hljs-comment">// which is different to Python where public is the default</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">private</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wuff</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;Wuff, wuff!\n&quot;</span>;
    }
<span class="hljs-comment">// Animal 클래스를 private로 상속받았기 때문에, 외부에서 run, eat 함수를 호출할 수 없다.</span>
<span class="hljs-comment">// we must reimplement run and call Animal::run()</span>
<span class="hljs-comment">// by the Dog::run() method</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        Animal::<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// Animal 클래스의 run() 메서드 호출</span>
        <span class="hljs-comment">// 외부에서 접근이 불가하기 때문에, 이렇게 클래스 내부에서 재 구현 하여 사용해야한다.</span>
    }
};


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Cat mike = <span class="hljs-built_in">Cat</span>();
    Dog fido = <span class="hljs-built_in">Dog</span>();

    mike.<span class="hljs-built_in">run</span>();   <span class="hljs-comment">// Cat 클래스에서 상속받은 run() 메서드 호출</span>
    mike.<span class="hljs-built_in">eat</span>();   <span class="hljs-comment">// Animal 클래스에서 상속받은 eat() 메서드 호출</span>
    mike.<span class="hljs-built_in">meow</span>();  <span class="hljs-comment">// Cat 클래스의 meow() 메서드 호출</span>

    fido.<span class="hljs-built_in">run</span>();   <span class="hljs-comment">// Dog 클래스에서 재구현한 run() 메서드 호출</span>
    <span class="hljs-comment">// fido.eat(); // 컴파일 오류: private 상속으로 인해 eat() 메서드 접근 불가</span>
    fido.<span class="hljs-built_in">wuff</span>();  <span class="hljs-comment">// Dog 클래스의 wuff() 메서드 호출</span>
}
</code></pre>
<h3 id="base-class-constructor">Base Class Constructor</h3>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">protected</span>:
    std::string name;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Animal</span>(std::string name) { <span class="hljs-comment">// constructor</span>
        <span class="hljs-keyword">this</span>-&gt;name = name;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot; runs! &quot;</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Cat</span>(std::string name) : <span class="hljs-built_in">Animal</span>(name) { } <span class="hljs-comment">// 부모클래스의 생성자를 불러온다. super.와 비슷하다고 생각하면 될 듯</span>

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">meow</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot; says meow!\n&quot;</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>{
    <span class="hljs-function">Cat <span class="hljs-title">micky</span><span class="hljs-params">(<span class="hljs-string">&quot;Micky&quot;</span>)</span></span>;

    micky.<span class="hljs-built_in">run</span>();   <span class="hljs-comment">// &quot;Micky runs! &quot; 출력</span>
    micky.<span class="hljs-built_in">meow</span>();  <span class="hljs-comment">// &quot;Micky says meow!&quot; 출력</span>
}

</code></pre>
<h3 id="composition">Composition</h3>
<p>그렇지. Inheritance가 나왔으면 Composition도 있어야겠지?</p>
<p>Part-of 관계를 가진다. inheritance는 is-a 관계였고.</p>
<p>객체들간의 강한 소유 관계가 필요할 때 사용한다. 또한, 기본 베이스 클래스에서 다는 필요없고 일부 메서드만 필요한 경우 상속보다는 composition을 통해 필요한 것만 빼올 수 있다. 그냥 import하면 안되나..?</p>
<p>암튼, 베이스 클래스의 일부 메서드를 외부에 감추고자 할 때나, 여러 구성요소로 메서드를 위임하고자 할때 사용할 수 있다.</p>
<p>파이썬에서의 예시를 보자.</p>
<pre><code class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tail</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wag</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Wag, wag!&#x27;</span>)
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,breed</span>):
        self.tail=Tail() <span class="hljs-comment"># component</span>
        self.name=name
        self.breed=breed
        self.confidence=<span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">chase</span>(<span class="hljs-params">self,thing</span>):
        <span class="hljs-built_in">print</span>(self.name,<span class="hljs-string">&#x27; chases &#x27;</span>,thing)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Wuff! Wuff!&#x27;</span>, end=<span class="hljs-string">&#x27; &#x27;</span>)
        self.tail.wag()
        self.confidence=self.confidence+<span class="hljs-number">1</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getConfidence</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> self.confidence &gt; <span class="hljs-number">3</span>:
            <span class="hljs-keyword">return</span>(<span class="hljs-string">&#x27;confidence of &#x27;</span>+ self.name+<span class="hljs-string">&#x27; is good!&#x27;</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span>(<span class="hljs-string">&#x27;confidence of &#x27;</span>+ self.name+<span class="hljs-string">&#x27; is ok!&#x27;</span>)

fido=Dog(<span class="hljs-string">&#x27;Fido&#x27;</span>,<span class="hljs-string">&#x27;Australian Shepherd&#x27;</span>)
<span class="hljs-keyword">for</span> cat <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;Susi&#x27;</span>,<span class="hljs-string">&#x27;Kathi&#x27;</span>, <span class="hljs-string">&#x27;Moritz&#x27;</span>]:
    fido.chase(<span class="hljs-string">&#x27;cat &#x27;</span>+cat)
<span class="hljs-built_in">print</span>(fido.getConfidence())
fido.chase(<span class="hljs-string">&#x27;Student Martin&#x27;</span>)
<span class="hljs-built_in">print</span>(fido.getConfidence())
<span class="hljs-built_in">print</span>(fido.tail.wag()) <span class="hljs-comment"># bad style</span>
</code></pre>
<p>파이썬에선 대충 요런식으로 썻었다.</p>
<p>C++에서도 사용 방법은 동일하다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tail</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wag</span> <span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;Wag, wag!&quot;</span> &lt;&lt; std::endl; }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Dog</span>(std::string name, std::string breed);
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getConfidence</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span>(confidence); }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chase</span> <span class="hljs-params">(std::string thing)</span></span>;
<span class="hljs-keyword">protected</span>:
    <span class="hljs-type">int</span> confidence = <span class="hljs-number">0</span>;
    std::string itsName ;
    std::string itsBreed;
    Tail itsTail;
};
Dog::<span class="hljs-built_in">Dog</span>(std::string name, std::string breed) { <span class="hljs-comment">// constructor</span>
    itsName = name;
    itsBreed=breed;
    itsTail = <span class="hljs-built_in">Tail</span>(); <span class="hljs-comment">// composition, dog 클래스의 멤버로 tail 클래스를 가져온다</span>
                    <span class="hljs-comment">// 명백한 has-a relationship</span>
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::chase</span> <span class="hljs-params">(std::string thing)</span> </span>{
    std::cout &lt;&lt; itsName &lt;&lt; <span class="hljs-string">&quot; chases &quot;</span>&lt;&lt;thing&lt;&lt; <span class="hljs-string">&quot;!&quot;</span>&lt;&lt;std::endl;
    itsTail.<span class="hljs-built_in">wag</span>();
    confidence += <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Dog <span class="hljs-title">fido</span><span class="hljs-params">(<span class="hljs-string">&quot;Fido PEX XXII&quot;</span>,<span class="hljs-string">&quot;Australian Shepherd&quot;</span>)</span></span>;
    fido.<span class="hljs-built_in">chase</span>(<span class="hljs-string">&quot;Kathi PEX XXII&quot;</span>);
    std::cout&lt;&lt;<span class="hljs-string">&quot;Fido confidence: &quot;</span>&lt;&lt;fido.<span class="hljs-built_in">getConfidence</span>()&lt;&lt;std::endl;}
</code></pre>
<h3 id="multiple-inharitance">Multiple Inharitance</h3>
<p>하나의 클래스가 여러개의 다른 클래스로부터 상속을 받을 수 있다. 파이썬에서도 가능했고 했지만, c++에서는 지양되는 방식중 하나이다. 왜냐면 다이아몬드 문제를 일으킬 수 있기 때문이다.</p>
<p>만약 두개의 클래스 a,b 를 상속받을때, 이 둘 모두 하나의 동일한 클래스 c로부터 상속받는 중이라면, c클래스의 멤버가 중복될 수 있다. 이러면 충돌이 일어난다.</p>
<p>따라서, 이를 해결하기위해 C++에서는 virtual inheritance를 지원한다.</p>
<p>Multiple inheritance를 사용하여 Mixin을 사용할수도 있지만, Multiple inheritance 자체를 사용하는건 되도록이면 지양하자.</p>
<p>그래도 예시는 보고 가야지?</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span> <span class="hljs-params">()</span> </span>{
    cout &lt;&lt; <span class="hljs-string">&quot;I believe I can fly ...&quot;</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">beat</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// can&#x27;t have eat in Bird and Horse</span>
    cout &lt;&lt; <span class="hljs-string">&quot;Mhmm, dendrobena ...&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// ?</span>
    }
    };
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Horse</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>{
    cout &lt;&lt; <span class="hljs-string">&quot;Run, run, run, ...&quot;</span> &lt;&lt; endl;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heat</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// can&#x27;t have eat in Bird and Horse</span>
    cout &lt;&lt; <span class="hljs-string">&quot;Mhmm, apples ...&quot;</span> &lt;&lt; endl;
    }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pegasus</span> : <span class="hljs-keyword">public</span> Bird, <span class="hljs-keyword">public</span> Horse {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">whoami</span> <span class="hljs-params">()</span> </span>{
    cout &lt;&lt; <span class="hljs-string">&quot;Pegasus&quot;</span> &lt;&lt; endl;
    }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    Pegasus pegi;
    pegi.<span class="hljs-built_in">fly</span>();
    pegi.<span class="hljs-built_in">run</span>();
    pegi.<span class="hljs-built_in">beat</span>(); <span class="hljs-comment">// can&#x27;t have eat in Bird and Horse</span>
    pegi.<span class="hljs-built_in">heat</span>(); <span class="hljs-comment">// can&#x27;t have eat in Bird and Horse</span>
    pegi.<span class="hljs-built_in">whoami</span>();
}
</code></pre>
<h3 id="abstract-class">Abstract Class</h3>
<p>Abstract class는 위에서 언급한 가상함수를 사용하는 예이다. abstract class는 인터페이스를 정의하게 되는데, 자식 클래스에서 구현될 메서드들의 집합을 먼저 선언하고, 이들 메서드는 인터페이스를 따르는 모든 객체에 대해 동일한 방식으로 호출될 수 있다.</p>
<p>abstract class는 하나 이상의 pure virtual function를 포함하는데, <code>virtual</code> 키워드와 함께 <code>= 0</code>으로 정의되는 함수이다. 이 함수는 abstract class 내에서 구현되지 않으며, 파생 자식 클래스에서 반드시 override되어야 한다. 또한, 자식 클래스는 반드시 이것을 정의하고 넘어가야 한다. 이는 프로그램의 일관성을 유지시키며, 템플릿 역할을 수행할 수 있다.</p>
<p>abstract class는 pure virtual function 외에도 일반적인 멤버 함수나 데이터 멤버를 포함할 수 있다. 이들은 기본적인 동작을 제공하거나, 파생 클래스에서 공통적으로 사용할 수 있는 기능을 제공한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// 추상 클래스 Animal 정의</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 순수 가상 함수 pure virtual function</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 동물의 소리를 출력하는 함수</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;          <span class="hljs-comment">// 동물이 먹이를 먹는 함수</span>
    
    <span class="hljs-comment">// 일반 멤버 함수</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal is sleeping&quot;</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-comment">// 추상 클래스 Animal을 상속받는 파생 클래스 Dog 정의</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 순수 가상 함수를 오버라이드하여 구현</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;Woof!&quot;</span> &lt;&lt; std::endl;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;Dog is eating bones&quot;</span> &lt;&lt; std::endl;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Animal은 추상 클래스이므로 직접 객체를 생성할 수 없음</span>
    <span class="hljs-comment">// Animal animal; // 컴파일 오류: 추상 클래스의 객체 생성 불가</span>

    Dog dog;
    dog.<span class="hljs-built_in">sound</span>();  <span class="hljs-comment">// Dog 클래스에서 구현한 sound 함수 호출</span>
    dog.<span class="hljs-built_in">eat</span>();    <span class="hljs-comment">// Dog 클래스에서 구현한 eat 함수 호출</span>
    dog.<span class="hljs-built_in">sleep</span>();  <span class="hljs-comment">// Animal 클래스에서 상속받은 sleep 함수 호출</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="mixin">Mixin</h3>
<p>C++에는 딱히 mixin이라는 기능이 없다. 하지만 multiple inheritance를 사용해서 mixin기능을 흉내낼 수 있다.</p>
<p>Mixin 클래스의 경우, 일반적으로 인스턴스화되면 안된다. multiple inheritance를 사용하기 때문에 인스턴스화가 될 수 있지만, 하면 안된다.</p>
<p>Mixin 클래스는 다른 클래스에서 필요한 기능을 제공하기 위해 포함될 수 있다.</p>
<p>예시를 보자!</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">float</span> km = <span class="hljs-number">0</span>;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;I am eating every day ...!\n&quot;</span>; }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">float</span> km)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;km = <span class="hljs-keyword">this</span>-&gt;km + km;
        std::cout &lt;&lt; <span class="hljs-string">&quot;running &quot;</span> &lt;&lt; <span class="hljs-built_in">getKm</span>() &lt;&lt; <span class="hljs-string">&quot;km!&quot;</span> &lt;&lt; std::endl;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getKm</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;km); }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;I am eating mice! \n&quot;</span>; }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SingerMixin</span> { <span class="hljs-comment">// Mixin, 메서드가 하나 정의되어있다. </span>
<span class="hljs-keyword">protected</span>:
    std::string song = <span class="hljs-string">&quot;Lala, lalalaaaa!\n&quot;</span>;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sing</span><span class="hljs-params">(<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            std::cout &lt;&lt; song;
        }
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SingingPerson</span> : <span class="hljs-keyword">public</span> Person, <span class="hljs-keyword">public</span> SingerMixin { }; <span class="hljs-comment">// mixin 사용</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SingingCat</span> : <span class="hljs-keyword">public</span> Cat, <span class="hljs-keyword">public</span> SingerMixin { <span class="hljs-comment">// mixin을 다중상속 받는다. </span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">SingingCat</span>() { song = <span class="hljs-string">&quot;Meow - I love Lasagne!\n&quot;</span>; }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    SingingPerson bob;
    bob.<span class="hljs-built_in">eat</span>();
    bob.<span class="hljs-built_in">sing</span>();
    bob.<span class="hljs-built_in">run</span>(<span class="hljs-number">2.5</span>);
    std::cout &lt;&lt; <span class="hljs-string">&quot;Bob ran &quot;</span> &lt;&lt; bob.<span class="hljs-built_in">getKm</span>() &lt;&lt; <span class="hljs-string">&quot;km!&quot;</span> &lt;&lt; std::endl;

    SingingCat garfield;
    garfield.<span class="hljs-built_in">eat</span>();
    garfield.<span class="hljs-built_in">sing</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// mixin으로 받은 함수를 사용할 수 있다. </span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="virtual-functions">Virtual Functions</h3>
<p>코드의 polymorphism을 구현하는 주요 매커니즘 중 하나이다. 이를 사용하면 상속관계에서 동일한 메서드의 이름을 사용하면서 각각의 클래스에 맞는 특정 동작을 구현할 수 있다.</p>
<p><code>virtual</code> 키워드를 통해 정의될 수 있으며, 파생 클래스에서는 이걸 오버라이딩해서 사용한다. 오버라이딩 할때는 함수 뒤에 <code>override</code>라는 키워드를 포함해야하며, <strong>함수의 이름, 매개변수 형식, 반환 유형 또한 동일해야한다.</strong></p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating generic food. &quot;</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{ 
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating a rat. &quot;</span>; 
    }
};

<span class="hljs-comment">// Function which gets an object as argument!!</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gomensa</span><span class="hljs-params">(Animal&amp; xyz)</span> </span>{ 
    xyz.<span class="hljs-built_in">eat</span>(); 
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    Animal ani = <span class="hljs-built_in">Animal</span>();
    Cat cat = <span class="hljs-built_in">Cat</span>();
    
    ani.<span class="hljs-built_in">eat</span>(); <span class="hljs-comment">// Outputs: &quot;I&#x27;m eating generic food.&quot;</span>
    cat.<span class="hljs-built_in">eat</span>(); <span class="hljs-comment">// Outputs: &quot;I&#x27;m eating a rat.&quot;</span>
    
    std::cout &lt;&lt; std::endl &lt;&lt; <span class="hljs-string">&quot;But in the mensa: &quot;</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">gomensa</span>(ani);
    <span class="hljs-built_in">gomensa</span>(cat); <span class="hljs-comment">// Now it outputs: &quot;I&#x27;m eating a rat.&quot;</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</code></pre>
<p>가상함수를 이용하여 다음의 문제를 해결하는 과정을 살펴보도록 하자.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating generic food. &quot;</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating a rat. &quot;</span>;
    }
};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gomensa</span><span class="hljs-params">(Animal xyz)</span> </span>{ 
    xyz.<span class="hljs-built_in">eat</span>(); 
}

<span class="hljs-comment">// we add another func for cats&#x27; but that is tedious ...</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gomensa</span><span class="hljs-params">(Cat xyz)</span> </span>{ 
    xyz.<span class="hljs-built_in">eat</span>(); 
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> ani = <span class="hljs-built_in">Animal</span>(); <span class="hljs-comment">// or Animal animal = Animal();</span>
    <span class="hljs-keyword">auto</span> cat = <span class="hljs-built_in">Cat</span>();
    
    ani.<span class="hljs-built_in">eat</span>();
    cat.<span class="hljs-built_in">eat</span>();
    
    std::cout &lt;&lt; <span class="hljs-string">&quot;Now in the mensa: &quot;</span> &lt;&lt; std::endl;
    
    <span class="hljs-built_in">gomensa</span>(ani);
    <span class="hljs-built_in">gomensa</span>(cat);
}
</code></pre>
<p>이 코드에는 문제가 있다. 딱히 문제가 없어 보이지만, 출력을 해보면 알 수 있다.</p>
<pre><code>I'm eating generic food. I'm eating a rat. Now in the mensa:
I'm eating generic food. I'm eating a rat.
</code></pre>
<p>우리는 먼저 <code>Animal</code>과 <code>Cat</code>클래스의 객체를 하나씩 생성한다. 두 클래스에서는 모두 각각 <code>eat()</code>이라는 이름의 함수가 정의되어 있다. Cat의 eat은 Animal로부터 상속받은 것이다.</p>
<p>우리의 main 함수에서, 우리는 <code>ani.eat()</code>과 <code>cat.eat()</code>에서 우리가 기대했던대로 각각의 클래스에서 정의된 함수가 잘 작동하는것을 볼 수 있다.</p>
<p>또한, 클래스의 외부에서, 각각 Cat을 받았을때와 Animal을 받았을때 따로따로 각각의 클래스 멤버 함수를 호출하는 함수를 정의했다. 이후 main 함수에서 우리가 <code>gomensa(ani)</code>와 <code>gomensa(cat)</code>을 호출했을 때, 위 두 함수와 같은 기능을 하길 기대할 수 있다.</p>
<p>그러나 이것을 하려면 모든 객체의 클래스에 대해 클래스 외부에서 각각 해당하는 클래스 만큼의 추가적인 함수를 정의해야한다는 문제가 있다. 사실 이런게 한두개면 상관이 없는데, 한 대여섯개를 넘어가는 순간 매우 귀찮고 비효율 적인 작업이 될 것이다. 이것을 <strong>virtual function</strong>를 이용한 <strong>dynamic binding</strong>으로 해결할 수 있다.</p>
<p>첫번째 과정을 보자.</p>
<h4 id="using-pointer-and-reference">Using Pointer and Reference</h4>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating generic food. &quot;</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating a rat. &quot;</span>;
    }
};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gomensa</span><span class="hljs-params">(Animal *xyz)</span> </span>{
    xyz-&gt;<span class="hljs-built_in">eat</span>();
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> *ani = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Animal</span>();  <span class="hljs-comment">// Animal 객체의 포인터 생성</span>
    <span class="hljs-keyword">auto</span> *cat = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>();     <span class="hljs-comment">// Cat 객체의 포인터 생성</span>
    <span class="hljs-keyword">auto</span> cat2 = <span class="hljs-built_in">Cat</span>();         <span class="hljs-comment">// Cat 객체 생성 (포인터 아님)</span>
    
    ani-&gt;<span class="hljs-built_in">eat</span>();   <span class="hljs-comment">// &quot;I&#x27;m eating generic food. &quot;</span>
    cat-&gt;<span class="hljs-built_in">eat</span>();   <span class="hljs-comment">// &quot;I&#x27;m eating a rat. &quot;</span>
    cat2.<span class="hljs-built_in">eat</span>();   <span class="hljs-comment">// &quot;I&#x27;m eating a rat. &quot;</span>
    
    std::cout &lt;&lt; std::endl &lt;&lt; <span class="hljs-string">&quot;Now: &quot;</span> &lt;&lt; std::endl;
    
    <span class="hljs-built_in">gomensa</span>(ani);      <span class="hljs-comment">// &quot;I&#x27;m eating generic food. &quot;</span>
    <span class="hljs-built_in">gomensa</span>(cat);      <span class="hljs-comment">// &quot;I&#x27;m eating a rat. &quot;</span>
    <span class="hljs-built_in">gomensa</span>(&amp;cat2);    <span class="hljs-comment">// &quot;I&#x27;m eating a rat. &quot; (주소를 전달)</span>
}

</code></pre>
<pre><code>I'm eating generic food. I'm eating a rat. I'm eating a rat.
Now:
I'm eating generic food. I'm eating a rat. I'm eating a rat.
</code></pre>
<p>이 예시에서, 우리는 <code>gomensa()</code>함수를 단 하나만 정의했다. 그리고, 이 함수의 파라미터에 우리는 <code>Animal *xyz</code>, 즉 포인터를 사용했다. 이 경우, <code>gomensa</code>함수는 <code>Animal</code>타입의 포인터를 매개변수로 받아, 해당 객체의 <code>eat()</code>함수를 호출한다. 포인터를 사용함으로써, 객체의 실제 타입에 따라 올바른 가상함수가 호출된다.</p>
<p>레퍼런스를 사용해서도 구현이 가능하다.</p>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gomensa</span><span class="hljs-params">(Animal&amp; xyz)</span> </span>{ <span class="hljs-comment">// 참조자로 변경</span>
    xyz.<span class="hljs-built_in">eat</span>();
}
</code></pre>
<h4 id="using-template-and-auto">Using Template and Auto</h4>
<p>위의 형태를 Template 혹은 Auto로도 사용할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating generic food. &quot;</span>;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating a rat. &quot;</span>;
    }
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gomensa</span><span class="hljs-params">(T xyz)</span> </span>{
    xyz.<span class="hljs-built_in">eat</span>();
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> ani = <span class="hljs-built_in">Animal</span>();
    <span class="hljs-keyword">auto</span> cat = <span class="hljs-built_in">Cat</span>();

    ani.<span class="hljs-built_in">eat</span>();    <span class="hljs-comment">// &quot;I&#x27;m eating generic food. &quot;</span>
    cat.<span class="hljs-built_in">eat</span>();    <span class="hljs-comment">// &quot;I&#x27;m eating a rat. &quot;</span>

    std::cout &lt;&lt; std::endl &lt;&lt; <span class="hljs-string">&quot;Now: &quot;</span> &lt;&lt; std::endl;

    <span class="hljs-built_in">gomensa</span>(ani); <span class="hljs-comment">// &quot;I&#x27;m eating generic food. &quot;</span>
    <span class="hljs-built_in">gomensa</span>(cat); <span class="hljs-comment">// &quot;I&#x27;m eating a rat. &quot;</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><code>gomensa(ani)</code>는 <code>Animal</code>객체를 전달하여 템플릿 함수가 <code>Animal</code>타입으로 인스턴스화 된다. <code>gomensa&lt;Animal&gt;(ani)</code>와 동일하게 동작하며, 제네릭 푸드를 출려한다.</p>
<p>마찬가지로, <code>gomensa(cat)</code>은 <code>Cat</code>을 전달하여 템플릿 함수가 <code>Cat</code>타입으로 인스턴스화 된다. <code>gomensa&lt;Cat&gt;(cat)</code>으로 작동한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating generic food. &quot;</span> ;
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m eating a rat. &quot;</span>; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gomensa</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> xyz)</span> </span>{ xyz.<span class="hljs-built_in">eat</span>(); } <span class="hljs-comment">// 객체의 클래스에 해당하는 함수를 불러오고, 객체를 자동 인식</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> ani = <span class="hljs-built_in">Animal</span>();
    <span class="hljs-keyword">auto</span> cat = <span class="hljs-built_in">Cat</span>();
    ani.<span class="hljs-built_in">eat</span>();
    cat.<span class="hljs-built_in">eat</span>();
    std::cout &lt;&lt; std::endl &lt;&lt;<span class="hljs-string">&quot;Now: &quot;</span> &lt;&lt; std::endl;
    <span class="hljs-built_in">gomensa</span>(ani);
    <span class="hljs-built_in">gomensa</span>(cat);
}
</code></pre>
<p>당연히? auto도 잘 작동한다. auto가 그리고 제일 간단하다. auto 쓰자 그냥.</p>
<h2 id="stylistic-rules">Stylistic rules</h2>
<p>스타일리스틱 룰은 일관성있고 가독성 높은 코드를 작성하기 위한 지침이다.</p>
<ol>
<li>클래스를 여러개 만들고 싶으면, 클래스 마다 별도의 파일을 작성한다. 또한, 클래스의 이름과 파일 이름을 일치시킨다.</li>
<li>소스파일과 헤더파일의 확장자를 다르게 사용한다. 소스파일의 경우 <code>.cpp</code>, <code>.cxx</code>, <code>.cc</code>가 될 것이고, 헤더파일은 <code>.h</code>, <code>.hpp</code>, <code>.hxx</code>가 될 것이다.</li>
<li>클래스의 이름은 대문자로 시작한다.</li>
<li>객체의 이름은 소문자로 시작한다. 예) <code>Animal fido(&quot;Fido&quot;)</code></li>
<li>긴 이름은 CamelCase 또는 Under_Scores를 사용한다.</li>
<li>모든 상수는 대문자로 작성한다. 예) <code>const int MAX_SPEED = 100;</code></li>
<li><code>#define</code>의 사용을 피하고, 웬만하면 <code>const</code>를 사용한다.</li>
<li>네임스페이스를 잘 사용하자.</li>
<li>multiple inheritance의 사용을 피한다.</li>
<li>파일 시작 부분에 라이선스와 작성자 정보를 추가한다.</li>
</ol>
<h2 id="regex">Regex</h2>
<p>교수님이 사랑해 마지않는, Regex와 CLA의 시간이 돌아왔다.</p>
<p>C++에서 Regex를 사용하기 위해선, <code>&lt;regex&gt;</code>헤더파일이 필요하다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>{
    <span class="hljs-function">regex <span class="hljs-title">rxFullname</span><span class="hljs-params">(<span class="hljs-string">&quot;[A-Z][a-z]+ [A-Z][a-z]+&quot;</span>)</span></span>;
    string name;
    
    cout &lt;&lt; <span class="hljs-string">&quot;Enter your full name: &quot;</span> &lt;&lt; flush;
    <span class="hljs-built_in">getline</span>(cin, name);  <span class="hljs-comment">// 전체 입력 줄을 읽습니다.</span>

    <span class="hljs-comment">//string name = &quot;Detlef Groth&quot;;</span>
    <span class="hljs-comment">//cout &lt;&lt; &quot;Enter you full name: &quot; &lt;&lt; flush;</span>
    <span class="hljs-comment">//cin &gt;&gt; name;</span>
    <span class="hljs-comment">// cin은 공백을 기준으로 입력을 분리하기 때문에 전체 이름을 제대로 읽지 못한다.</span>
    <span class="hljs-comment">// getline을 사용하여 전체 입력 줄을 읽는 것이 권장된다. </span>
    
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">regex_match</span>(name, rxFullname)) {
        cout &lt;&lt; <span class="hljs-string">&quot;\nError: Name not entered correctly, your name is &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;&#x27;??&quot;</span> &lt;&lt; endl;
    } <span class="hljs-keyword">else</span> {
        cout &lt;&lt; <span class="hljs-string">&quot;Great, you entered the name correctly as: &quot;</span> &lt;&lt; name &lt;&lt; endl;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>자 그러면 다시한번 Regex의 syntax에 대해 차근차근 알아보도록 하자.</p>
<ul>
<li><code>[]</code>: 문자 클래스를 나타내며, 대괄호 안에있는 문자 중하나와 일치 하는지를 검사한다. 예를들어 <code>[abc]</code>는 a, b, c 중 하나와 일치하는지 검사한다.</li>
<li><code>.</code>: 어떤 문자 하나와 일치하는지를 찾는다. <code>a.</code>는 <code>ab</code>, <code>ac</code>등이 될 수 있다.</li>
<li><code>?</code>: 직전의 패턴이 없는지 본다.</li>
<li><code>*</code>: 직전의 패턴이 있을 수 있다. 0회 이상..</li>
<li><code>+</code>: 직전의 패턴이 1회 이상 반복된다.</li>
<li><code>|</code>: OR 연산을 나타내며, 왼쪽 또는 오른쪽의 패턴 중 하나와 일치하는지 검사한다.</li>
<li><code>{}</code>:반복 횟수를 지정한다. <code>{n}</code>은 정확히 n번 반복을 나타내고, <code>{m,n}</code>은 최소 m번에서 최대 n번 반복을 나타낸다.</li>
<li><code>()</code>: 그룹을 지정한다. 그룹화된 패턴은 후속작업에서 참조할 수 있다.</li>
<li><code>\s</code> 공백, <code>\t</code> 탭, <code>\n</code> 줄바꿈, <code>\w</code> 단어 문자 (소문자, 대문자, 숫자, 밑줄을 포함)</li>
</ul>
<p>Unix/Linux 환경에서 Regex의 이용은 필수이다. 이게없으면 돌아가질 않는다.</p>
<p>Regex는 보통 <code>grep</code>명령어와 자주 함께 쓰이는데, 기본 형식은 다음과 같다.</p>
<pre><code class="language-bash">grep [options] pattern [filename(s)]
</code></pre>
<p>여기에 이제 <code>-E</code> 옵션을 붙이면 Regex를 사용할 수 있다.</p>
<pre><code class="language-bash">grep -E <span class="hljs-string">&quot;regex&quot;</span> filename(s)
</code></pre>
<p>이 명령어는 &quot;regex&quot;라는 단어가 포함된 모든 라인을 출력한다.</p>
<p><code>egrep</code>은 <code>grep -E</code>의 축약형으로, 위에 말한 기능을 수행한다.</p>
<p>아래 사용 예시를 보자.</p>
<ol>
<li>
<p><strong>“A”</strong>: standard IUPAC one-letter codes</p>
<ul>
<li><code>&quot;A&quot;</code>는 특정한 IUPAC 아미노산 코드를 나타내며, 여기서는 Alanine (알라닌)을 나타냅니다.</li>
</ul>
</li>
<li>
<p><strong>“.”</strong>: position where any aa is accepted</p>
<ul>
<li><code>&quot;.&quot;</code>은 어떤 아미노산이든 허용되는 위치를 나타냅니다. 즉, 어떤 한 문자에 대응됩니다.</li>
</ul>
</li>
<li>
<p><strong>“[ALT]”</strong>: ambiguity any of Ala or Leu or Thr</p>
<ul>
<li><code>&quot;[ALT]&quot;</code>는 Ala (Alanine), Leu (Leucine), Thr (Threonine) 중 하나에 대응됩니다. 즉, 이 위치에서는 이 세 가지 아미노산 중 하나가 올 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>“[^AL]”</strong>: negative ambiguity any aa but not! Ala or Leu.</p>
<ul>
<li><code>&quot;[^AL]&quot;</code>은 Ala (Alanine) 또는 Leu (Leucine)이 아닌 다른 아미노산을 나타냅니다. 즉, 이 위치에서는 Ala와 Leu를 제외한 다른 아미노산이 올 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>“.{2,4}”</strong>: repetition. two to four amino acids of any type</p>
<ul>
<li><code>&quot;.{2,4}&quot;</code>는 어떤 아미노산이든 2개에서 4개까지의 문자열에 대응됩니다. 즉, 2개 이상 4개 이하의 아미노산이 올 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>“L{3}”</strong>: exactly three Leu</p>
<ul>
<li><code>&quot;L{3}&quot;</code>은 정확히 세 번의 Leucine (Leu)을 나타냅니다. 따라서 &quot;LLL&quot;과 같은 패턴에 매칭됩니다.</li>
</ul>
</li>
<li>
<p><strong>“L{2,4}”</strong>: two to four Leu, why not :)</p>
<ul>
<li><code>&quot;L{2,4}&quot;</code>는 Leucine (Leu)가 2개에서 4개까지 나타날 수 있는 패턴을 나타냅니다. 따라서 &quot;LL&quot;, &quot;LLL&quot;, &quot;LLLL&quot;과 같은 패턴에 매칭됩니다.</li>
</ul>
</li>
<li>
<p><strong>“+”</strong>: one or more, X+ == X{1,}</p>
<ul>
<li><code>&quot;+&quot;</code>는 바로 앞의 패턴이 한 번 이상 반복됨을 나타냅니다. 즉, &quot;X+&quot;는 &quot;X&quot;가 한 번 이상 나오는 패턴을 의미합니다.</li>
</ul>
</li>
<li>
<p><strong>“*”</strong>: zero or more, X* == X{0,}</p>
<ul>
<li><code>&quot;*&quot;</code>는 바로 앞의 패턴이 0회 이상 반복됨을 나타냅니다. 즉, &quot;X*&quot;는 &quot;X&quot;가 0회 이상 나오는 패턴을 의미합니다.</li>
</ul>
</li>
<li>
<p><strong>“?”</strong>: zero or one, X? == X{0,1}</p>
<ul>
<li><code>&quot;?&quot;</code>는 바로 앞의 패턴이 0회 또는 1회 나오는지를 나타냅니다. 즉, &quot;X?&quot;는 &quot;X&quot;가 0회 또는 1회 나오는 패턴을 의미합니다.</li>
</ul>
</li>
<li>
<p><strong>“^M”</strong>: N terminal Met</p>
<ul>
<li><code>&quot;^M&quot;</code>은 문자열의 시작 부분에 있는 Met (Methionine)을 나타냅니다. 즉, 문자열이 &quot;M&quot;으로 시작하는지를 검사합니다.</li>
</ul>
</li>
<li>
<p><strong>“A$”</strong>: C terminal Ala</p>
<ul>
<li><code>&quot;A$&quot;</code>은 문자열의 끝 부분에 있는 Ala (Alanine)을 나타냅니다. 즉, 문자열이 &quot;A&quot;로 끝나는지를 검사합니다.</li>
</ul>
</li>
</ol>
<h3 id="regex-functions">regex functions</h3>
<p>Regex를 사용하는데 유용한 functions들이 있다. 이 형태는 파이썬과 비슷하지만 조금 다르므로 자세히 알아보자.</p>
<ol>
<li>
<p><strong><code>std::regex_match</code></strong></p>
<ul>
<li><strong>설명</strong>: 문자열 전체가 정규 표현식과 일치하는지 여부를 확인합니다.</li>
<li><strong>기본 형태</strong>:</li>
<li><strong>사용 예시</strong>:<pre><code class="language-cpp">std::string str = <span class="hljs-string">&quot;Hello World&quot;</span>;
<span class="hljs-function">std::regex <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(str, reg)) {
    std::cout &lt;&lt; <span class="hljs-string">&quot;Match found!\n&quot;</span>;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong><code>std::regex_search</code></strong></p>
<ul>
<li><strong>설명</strong>: 문자열에서 정규 표현식과 일치하는 부분을 찾습니다.</li>
<li><strong>기본 형태</strong>: <code>regex_search(string, pattern,flag(s))</code></li>
<li><strong>사용 예시</strong>:<pre><code class="language-cpp">std::string str = <span class="hljs-string">&quot;abc def ghi&quot;</span>;
<span class="hljs-function">std::regex <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-string">&quot;\\b\\w{3}\\b&quot;</span>)</span></span>;  <span class="hljs-comment">// 정규 표현식: 세 글자로 이루어진 단어</span>
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(str, reg)) {
    std::cout &lt;&lt; <span class="hljs-string">&quot;Pattern found!\n&quot;</span>;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong><code>std::regex_replace</code></strong></p>
<ul>
<li><strong>설명</strong>: 문자열에서 정규 표현식과 일치하는 부분을 다른 문자열로 치환합니다.</li>
<li><strong>기본 형태</strong>: <code>regex_replace(string, pattern, replace)</code></li>
<li><strong>사용 예시</strong>:<pre><code class="language-cpp">std::string str = <span class="hljs-string">&quot;apple orange banana&quot;</span>;
<span class="hljs-function">std::regex <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-string">&quot;\\b(\\w+)\\b&quot;</span>)</span></span>;  <span class="hljs-comment">// 각 단어를 캡처하는 정규 표현식</span>
std::string result = std::<span class="hljs-built_in">regex_replace</span>(str, reg, <span class="hljs-string">&quot;fruit&quot;</span>);
std::cout &lt;&lt; result &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <span class="hljs-comment">// 출력: &quot;fruit fruit fruit&quot;</span>
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong><code>std::regex_iterator</code></strong></p>
<ul>
<li><strong>설명</strong>: 문자열에서 정규 표현식과 일치하는 모든 부분을 반복적으로 가져오는 반복자를 생성합니다.</li>
<li><strong>사용 예시</strong>:<pre><code class="language-cpp">std::string str = <span class="hljs-string">&quot;cat dog bird&quot;</span>;
<span class="hljs-function">std::regex <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-string">&quot;\\b\\w+\\b&quot;</span>)</span></span>;  <span class="hljs-comment">// 각 단어를 캡처하는 정규 표현식</span>
<span class="hljs-function">std::sregex_iterator <span class="hljs-title">iter</span><span class="hljs-params">(str.begin(), str.end(), reg)</span></span>;
std::sregex_iterator end;
<span class="hljs-keyword">while</span> (iter != end) {
    std::cout &lt;&lt; iter-&gt;<span class="hljs-built_in">str</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    ++iter;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong><code>std::regex_constants::match_flag_type</code></strong></p>
<ul>
<li><strong>설명</strong>: <code>std::regex_match</code>와 <code>std::regex_search</code> 함수의 매치 동작을 제어하기 위한 상수 타입이다.</li>
<li><strong>사용 예시</strong>:<pre><code class="language-cpp">std::string str = <span class="hljs-string">&quot;Hello World&quot;</span>;
<span class="hljs-function">std::regex <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>, std::regex_constants::icase)</span></span>;  <span class="hljs-comment">// 대소문자 구분 없이 검색</span>
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(str, reg)) {
    std::cout &lt;&lt; <span class="hljs-string">&quot;Match found!\n&quot;</span>;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong><code>std::smatch</code></strong></p>
<ul>
<li><strong>설명</strong>: <code>std::regex_match</code> 또는 <code>std::regex_search</code>에서 매치된 결과를 저장하는 클래스이다.</li>
<li><strong>사용 예시</strong>:<pre><code class="language-cpp">std::string str = <span class="hljs-string">&quot;John: 555-1234&quot;</span>;
<span class="hljs-function">std::regex <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-string">&quot;(\\w+): (\\d+-\\d+)&quot;</span>)</span></span>;
std::smatch match;
<span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(str, match, reg)) {
    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; match[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;, Phone: &quot;</span> &lt;&lt; match[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
</li>
</ul>
</li>
</ol>
<p>또한, <code>grep</code>함수는 c++에 없지만 정의할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">namespace</span> pex {
    <span class="hljs-comment">// a C++ grep which works like the R grep</span>
<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">grep</span> <span class="hljs-params">(std::string pattern, std::string str, <span class="hljs-type">const</span> std::regex::flag_type &amp; flag = std::regex::basic)</span> </span>{
    std::regex rx;
    rx =std::<span class="hljs-built_in">regex</span>(pattern,flag);
    std::vector&lt;<span class="hljs-type">int</span>&gt; index_matches; <span class="hljs-comment">// results saved here</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">sregex_iterator</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), rx);
        it != std::<span class="hljs-built_in">sregex_iterator</span>(); ++it) {
            index_matches.<span class="hljs-built_in">push_back</span>(it-&gt;<span class="hljs-built_in">position</span>());
    }
    <span class="hljs-keyword">return</span>(index_matches);
}
<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">grep</span> <span class="hljs-params">(std::string pattern, std::vector&lt;std::string&gt; vstring, <span class="hljs-type">const</span> std::regex::flag_type &amp; flag = std::regex::basic)</span> </span>{
    std::regex rx;
    rx =std::<span class="hljs-built_in">regex</span>(pattern,flag);
    std::vector&lt;<span class="hljs-type">int</span>&gt; index_matches = {}; <span class="hljs-comment">// results saved here</span>
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> el : vstring) {
        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(el,rx)) {
            index_matches.<span class="hljs-built_in">push_back</span>(i);
        }
        i=i+<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span>(index_matches);
}
} <span class="hljs-comment">// END OF NAMESPACE</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span> </span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; res = pex::<span class="hljs-built_in">grep</span>(<span class="hljs-string">&quot;[Hh][ea]&quot;</span>, <span class="hljs-string">&quot;Hello and hallo world!&quot;</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> r : res)
        std::cout &lt;&lt; r &lt;&lt; std::endl;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : pex::<span class="hljs-built_in">grep</span>(<span class="hljs-string">&quot;H[ea]&quot;</span>,{<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;World!&quot;</span>, <span class="hljs-string">&quot;Hallo&quot;</span>,<span class="hljs-string">&quot;Welt!&quot;</span>,<span class="hljs-string">&quot;by&quot;</span>,<span class="hljs-string">&quot;hallo&quot;</span>})) {
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : pex::<span class="hljs-built_in">grep</span>(<span class="hljs-string">&quot;H[ea]&quot;</span>,{<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;World!&quot;</span>, <span class="hljs-string">&quot;Hallo&quot;</span>,<span class="hljs-string">&quot;Welt!&quot;</span>,<span class="hljs-string">&quot;by&quot;</span>,<span class="hljs-string">&quot;hallo&quot;</span>}, std::regex::icase)) {
        std::cout &lt;&lt; i &lt;&lt; std::endl;
    }
}
</code></pre>
<h3 id="command-line-options">Command Line Options</h3>
<p>커멘드라인 옵션은 소스 코드를 변경하지 않고도 애플리케이션을 동적으로 제어할 수 있는 방법이다. 사용자는 명령 줄에서 직접 인수를 전달하여 애플리케이션의 동작을 조정할 수 있다.</p>
<p>간단하게 정의를 먼저 짚고 넘어가도록 하자.</p>
<ol>
<li><strong>Sub-command</strong>: 얘는 애플리케이션이 수행할 다양한 작업이나 동작을 지정하는데 사용된다. 예를들어 Git에서 사용하는 <code>git clone</code>, <code>git commit</code>, <code>git pull</code>등이 subcommand가 될 수 있다. 일반적으로 애플리케이션 이름 다음에 위치하며, 주요 작업을 결정한다.</li>
<li><strong>Options</strong>: 주 명령어나 서브 커맨드의 동작을 수정한다. 플래그 또는 값을 요구하는 매개변수 형태가 있다.
<ol>
<li><strong>Flags</strong>: 존재 여부에 따라 True 혹은 False를 나타내는 옵션이다. 일반적으로 <code>-</code>뒤에 글자나 단어로 표시된다.</li>
<li><strong>Parameters</strong>: 값을 요구하는 옵션으로, 일반적으로 <code>--</code> 혹은 <code>=</code>로 표시된다.</li>
</ol>
<pre><code class="language-bash">app commit --message=<span class="hljs-string">&quot;버그 수정&quot;</span>
app pull --rebase
</code></pre>
</li>
<li><strong>Positional Arguments</strong>: <code>-</code>나 <code>--</code>없이 지정되는 변수로, 일반적으로 필수이며, 파일이름, 경로, 또는 데이터 등을 나타낸다. 보통 특정 순서나 지정된 위치가 이미 존재한다.<pre><code class="language-cpp">app process file.txt
</code></pre>
</li>
</ol>
<p>예시:</p>
<pre><code class="language-bash">app process --verbose --output=results.txt input_data.txt
</code></pre>
<p>아래는 C++에서 CLA를 이용한 애플리케이션의 구현 예시이다.</p>
<pre><code class="language-cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> HELP[] =
<span class="hljs-string">R&quot;(Example application, Max Musterman, University of Potsdam
Usage:
{0} (-h | --help)
{0} (-v | --verbose)
{0} --round 2 number
Options:
-h --help Show this screen.
--round n Rounding digits [default: 2]
)&quot;</span>;

<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> USAGE[] =
<span class="hljs-string">R&quot;(Usage: {0} [-h,--help -v,--verbose] --round n number
)&quot;</span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(std::string appname, <span class="hljs-type">bool</span> help = <span class="hljs-literal">false</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (help) {
        fmt::<span class="hljs-built_in">print</span>(HELP, appname);
    } <span class="hljs-keyword">else</span> {
        fmt::<span class="hljs-built_in">print</span>(USAGE, appname);
    }
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>{
    std::string appname = argv[<span class="hljs-number">0</span>];
    <span class="hljs-function">std::regex <span class="hljs-title">isnumber</span><span class="hljs-params">(<span class="hljs-string">&quot;^[+-]?([0-9]*[.])?[0-9]+$&quot;</span>)</span></span>;
    <span class="hljs-type">float</span> square = <span class="hljs-number">0</span>; <span class="hljs-comment">// 위치 인수: 숫자의 제곱</span>
    <span class="hljs-type">bool</span> square_set = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 위치 인수가 지정되었는지 여부</span>
    <span class="hljs-type">int</span> round = <span class="hljs-number">2</span>; <span class="hljs-comment">// 옵션: 반올림 자릿수, 기본값 2</span>
    <span class="hljs-type">bool</span> help = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 도움말 플래그</span>
    <span class="hljs-type">bool</span> verbose = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 자세한 출력 플래그</span>

    <span class="hljs-comment">// 명령줄 인자가 없는 경우 사용법 출력</span>
    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>) {
        <span class="hljs-built_in">usage</span>(appname);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span> &amp;&amp; std::<span class="hljs-built_in">regex_match</span>(argv[<span class="hljs-number">1</span>], isnumber)) {
        <span class="hljs-comment">// 인자가 하나이고 숫자인 경우, 제곱할 수를 설정</span>
        square = std::<span class="hljs-built_in">stof</span>(argv[<span class="hljs-number">1</span>]);
        square_set = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 인자를 반복하여 처리</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) {
            std::string <span class="hljs-built_in">carg</span>(argv[i]);
            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-h&quot;</span> == carg || <span class="hljs-string">&quot;--help&quot;</span> == carg) {
                help = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 도움말 플래그 설정</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;-v&quot;</span> == carg || <span class="hljs-string">&quot;--verbose&quot;</span> == carg) {
                verbose = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 자세한 출력 플래그 설정</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (carg == <span class="hljs-string">&quot;--round&quot;</span> || carg == <span class="hljs-string">&quot;-r&quot;</span>) {
                <span class="hljs-comment">// --round 옵션 처리</span>
                <span class="hljs-keyword">if</span> (argc &gt; i + <span class="hljs-number">1</span> &amp;&amp; std::<span class="hljs-built_in">regex_match</span>(argv[i + <span class="hljs-number">1</span>], isnumber)) {
                    round = std::<span class="hljs-built_in">stoi</span>(argv[i + <span class="hljs-number">1</span>]);
                    i = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 다음 인자로 이동</span>
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(carg, isnumber)) {
                <span class="hljs-comment">// 숫자인 경우, 제곱할 수 설정</span>
                square = std::<span class="hljs-built_in">stof</span>(carg);
                square_set = <span class="hljs-literal">true</span>;
            }
        }
    }

    <span class="hljs-comment">// 도움말 출력</span>
    <span class="hljs-keyword">if</span> (help) {
        <span class="hljs-built_in">usage</span>(appname, <span class="hljs-literal">true</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (square_set) {
        <span class="hljs-comment">// 제곱 값 계산 및 출력</span>
        <span class="hljs-keyword">if</span> (verbose) {
            std::cout &lt;&lt; <span class="hljs-string">&quot;Let&#x27;s be verbose!\n&quot;</span>;
        }
        std::cout &lt;&lt; <span class="hljs-string">&quot;square of: &quot;</span> &lt;&lt; square &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt;
            std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(round) &lt;&lt;
            square * square &lt;&lt; std::endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code>./app 4.5
square of: 4.5 is 20.25

./app --round 3 2.7
square of: 2.7 is 7.290

./app -v --round 1 3.14159
Let's be verbose!
square of: 3.14159 is 9.9
</code></pre>
<h4 id="argc">argc</h4>
<p>Argument count라고 하며, C++에서 argv나 argh등과 함께 명령줄 인수를 처리하는데 사용되는 변수들이다. 이들은 <code>main</code>함수의 매개변수로 전달된다.</p>
<p><code>argc</code>는 integer 타입의 변수로, 프로그램에 전달된 argument의 개수를 나타낸다.</p>
<pre><code class="language-bash">./program arg1 arg2 arg3
</code></pre>
<p>요로코롬 프로그램이 실행되었다면, <code>argc</code>는 3이 된다.</p>
<h4 id="argv">argv</h4>
<p>Argument vector이며, <code>char *argv[]</code> 또는 <code>char **argv[]</code>의 형태로, 프로그램에 전달된 각 인수를 포함하는 문자열 배열이다.</p>
<p><code>argv[0]</code>은 보통 프로그램의 이름을 가리키고, <code>argv[1]</code>, <code>argv[2]</code>등은 각각 첫번째, 두번째 사용자가 입력한 argument를 가리킨다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>{
    <span class="hljs-comment">// argc는 전달된 인수의 개수를 나타낸다.</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;Number of arguments: &quot;</span> &lt;&lt; argc &lt;&lt; std::endl;

    <span class="hljs-comment">// argv[0]는 항상 실행 파일의 이름을 가진다.</span>
    std::cout &lt;&lt; <span class="hljs-string">&quot;Program name: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; std::endl;

    <span class="hljs-comment">// 인수가 있는 경우, 각 인수를 출력한다.</span>
    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) {
        std::cout &lt;&lt; <span class="hljs-string">&quot;Arguments:&quot;</span> &lt;&lt; std::endl;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) {
            std::cout &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; argv[i] &lt;&lt; std::endl;
        }
    } <span class="hljs-keyword">else</span> {
        std::cout &lt;&lt; <span class="hljs-string">&quot;No arguments provided.&quot;</span> &lt;&lt; std::endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="argparse">argparse</h4>
<p>C++에는 Python의 argparse와 비슷한 명령줄 인수 파싱을 지원하는 라이브러리가 없지만, 몇 가지 대안이 있다. Boost.Program_options 라이브러리를 사용하여 명령줄 인수를 처리하는 것이 흔히 사용되는 방법이다.
그런데 참 시발 교수님은 비슷한걸 또 찾아내셨다. 표준 라이브러리 <code>unility</code>에 argparse를 제공하는 뭔가가 있나보다.</p>
<p>다음은 사용 예시이다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/argparse.hpp&quot;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>{
    <span class="hljs-function">argparse::ArgumentParser <span class="hljs-title">program</span><span class="hljs-params">(<span class="hljs-string">&quot;argparse&quot;</span>)</span></span>;
    <span class="hljs-comment">// 프로그램 이름을 &quot;argparse&quot;로 설정한 argparse 객체를 생성합니다.</span>
    program.<span class="hljs-built_in">add_argument</span>(<span class="hljs-string">&quot;number&quot;</span>)
        .<span class="hljs-built_in">help</span>(<span class="hljs-string">&quot;display the square of a given number&quot;</span>)
        .<span class="hljs-built_in">action</span>([](<span class="hljs-type">const</span> std::string&amp; value) {
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stof</span>(value); });
    program.<span class="hljs-built_in">add_argument</span>(<span class="hljs-string">&quot;-r&quot;</span>, <span class="hljs-string">&quot;--round&quot;</span>)
        .<span class="hljs-built_in">help</span>(<span class="hljs-string">&quot;the rounding digits&quot;</span>).<span class="hljs-built_in">default_value</span>(<span class="hljs-number">2</span>)
        .<span class="hljs-built_in">action</span>([](<span class="hljs-type">const</span> std::string&amp; value) {
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(value); });
    program.<span class="hljs-built_in">add_argument</span>(<span class="hljs-string">&quot;-v&quot;</span>, <span class="hljs-string">&quot;--verbose&quot;</span>)
        .<span class="hljs-built_in">help</span>(<span class="hljs-string">&quot;set verbose on&quot;</span>)
        .<span class="hljs-built_in">default_value</span>(<span class="hljs-literal">false</span>)
        .<span class="hljs-built_in">implicit_value</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">try</span> {
        program.<span class="hljs-built_in">parse_args</span>(argc, argv);
    }
    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; err) {
        std::cout &lt;&lt; err.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;
        std::cout &lt;&lt; program;
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">auto</span> input = program.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-string">&quot;number&quot;</span>);
    <span class="hljs-keyword">auto</span> round = program.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;--round&quot;</span>);
    <span class="hljs-keyword">auto</span> verbose = program.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-string">&quot;--verbose&quot;</span>);

    <span class="hljs-keyword">if</span> (verbose) { std::cout &lt;&lt; <span class="hljs-string">&quot;verbose is on\n&quot;</span>; }
    std::cout &lt;&lt; <span class="hljs-string">&quot;square of: &quot;</span> &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt;
        std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(round) &lt;&lt;
        input*input &lt;&lt; std::endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>이걸 왜하는거임?</p>
<h4 id="popl---program-options-parser-library">Popl - Program Options Parser Library</h4>
<p>popl은 C++ 프로그램의 명령줄 인수를 처리하기 위한 라이브러리이다. 이 라이브러리는 명령줄 인수를 파싱하고, 각 인수의 값을 쉽게 접근하고 사용할 수 있는 기능을 제공합니다. 주로 사용되는 기능은 다음과 같습니다:</p>
<ul>
<li>
<p>옵션 정의: popl을 사용하여 명령줄 옵션을 정의하고 설명을 추가할 수 있습니다. 예를 들어, 옵션의 이름, 단축 이름, 설명 등을 설정할 수 있습니다.</p>
</li>
<li>
<p>인수 파싱: 프로그램이 시작될 때 주어진 명령줄 인수를 파싱하여 각 옵션과 위치 인수의 값을 추출합니다.</p>
</li>
<li>
<p>옵션 및 위치 인수 접근: 파싱된 인수를 통해 각 옵션의 값을 가져올 수 있습니다. 이를 통해 프로그램 내에서 인수에 따라 다른 동작을 정의할 수 있습니다.</p>
</li>
<li>
<p>자동 생성된 도움말: popl은 정의된 옵션들을 바탕으로 자동으로 도움말 메시지를 생성할 수 있습니다. 이를 통해 사용자에게 프로그램의 사용법을 쉽게 설명할 수 있습니다.</p>
</li>
<li>
<p>예외 처리: 잘못된 인수나 옵션을 처리할 때 발생하는 예외를 처리할 수 있는 기능을 제공합니다.</p>
</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/popl.hpp&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> popl;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> </span>{
    <span class="hljs-comment">// OptionParser 객체 생성 및 프로그램 설명 설정</span>
    <span class="hljs-function">OptionParser <span class="hljs-title">app</span><span class="hljs-params">(<span class="hljs-string">&quot;poplex application\nUsage: poplex [options] number\nOptions&quot;</span>)</span></span>;

    <span class="hljs-comment">// 스위치 옵션 추가: -h 또는 --help</span>
    <span class="hljs-keyword">auto</span> help = app.<span class="hljs-built_in">add</span>&lt;Switch&gt;(<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;produce help message&quot;</span>);

    <span class="hljs-comment">// 스위치 옵션 추가: -v 또는 --verbose</span>
    <span class="hljs-keyword">auto</span> verbose = app.<span class="hljs-built_in">add</span>&lt;Switch&gt;(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-string">&quot;verbose&quot;</span>, <span class="hljs-string">&quot;set verbose on&quot;</span>);

    <span class="hljs-comment">// 값 옵션 추가: -r 또는 --round, 기본값은 2</span>
    <span class="hljs-keyword">auto</span> round = app.add&lt;Value&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;round&quot;</span>, <span class="hljs-string">&quot;rounding digits&quot;</span>, <span class="hljs-number">2</span>);

    <span class="hljs-comment">// 명령줄 인수 파싱</span>
    app.<span class="hljs-built_in">parse</span>(argc, argv);

    <span class="hljs-comment">// print auto-generated help message</span>
    <span class="hljs-comment">// 도움말 옵션(-h 또는 --help)이 설정된 경우 출력</span>
    <span class="hljs-keyword">if</span> (help-&gt;<span class="hljs-built_in">is_set</span>()) {
        cout &lt;&lt; app &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (verbose-&gt;<span class="hljs-built_in">is_set</span>()) {
        cout &lt;&lt; <span class="hljs-string">&quot;verbose is on\n&quot;</span>;
    }

    <span class="hljs-comment">// show unknown options</span>
    <span class="hljs-comment">// 알 수 없는 옵션 (정의되지 않은 옵션) 출력</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; unknown_option : app.<span class="hljs-built_in">unknown_options</span>()) {
        cout &lt;&lt; <span class="hljs-string">&quot;Error: unknown option: &quot;</span> &lt;&lt; unknown_option &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// positionals</span>
    <span class="hljs-comment">// 위치 인수 처리</span>
    <span class="hljs-type">float</span> number = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; arg : app.<span class="hljs-built_in">non_option_args</span>()) {
        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(arg, std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;[-+.0-9]+&quot;</span>))) {
            number = std::<span class="hljs-built_in">stof</span>(arg);
            cout &lt;&lt; <span class="hljs-string">&quot;square of: &quot;</span> &lt;&lt; number &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt;
                    std::fixed &lt;&lt;
                    std::<span class="hljs-built_in">setprecision</span>(round-&gt;<span class="hljs-built_in">value</span>()) &lt;&lt;
                    number * number &lt;&lt; std::endl;
        } <span class="hljs-keyword">else</span> {
            cout &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="hljs-string">&quot; is not a number!\n&quot;</span>;
        }
    }

    <span class="hljs-comment">// 만약 number가 0이면 도움말 출력</span>
    <span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span>) {
        cout &lt;&lt; app.<span class="hljs-built_in">help</span>();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="flagsh">flags.h</h4>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/flags.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>{
    <span class="hljs-comment">// args 객체 생성</span>
    <span class="hljs-function"><span class="hljs-type">const</span> flags::args <span class="hljs-title">args</span><span class="hljs-params">(argc, argv)</span></span>;

    <span class="hljs-comment">// round 옵션 가져오기: long 옵션 이름 &quot;round&quot;, 기본값 0</span>
    <span class="hljs-keyword">auto</span> round = args.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;round&quot;</span>, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// round 옵션이 0이면 short 옵션 이름 &quot;r&quot;을 확인하여 기본값 2 설정</span>
    <span class="hljs-keyword">if</span> (round == <span class="hljs-number">0</span>) {
        round = args.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-number">2</span>);
    }

    <span class="hljs-comment">// help 옵션 가져오기: long 옵션 이름 &quot;help&quot; 또는 short 옵션 이름 &quot;h&quot;, 기본값 false</span>
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> help = args.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-literal">false</span>) || args.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-literal">false</span>);

    <span class="hljs-comment">// position 인수 가져오기: 인덱스 0, 기본값 0</span>
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> square = args.<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// round 값 출력</span>
    std::cout &lt;&lt; round &lt;&lt; std::endl;

    <span class="hljs-comment">// 도움말 옵션이 설정된 경우 출력</span>
    <span class="hljs-keyword">if</span> (help) {
        std::cout &lt;&lt; <span class="hljs-string">&quot;Help!\n&quot;</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (square == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// square 값이 0인 경우 사용법 출력</span>
        std::cout &lt;&lt; <span class="hljs-string">&quot;Usage: app number\n&quot;</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// square 값이 있는 경우 제곱 결과 출력</span>
        std::cout &lt;&lt; <span class="hljs-string">&quot;square of: &quot;</span> &lt;&lt; square &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt;
                std::fixed &lt;&lt;
                std::<span class="hljs-built_in">setprecision</span>(round) &lt;&lt;
                square * square &lt;&lt; std::endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="structopt">Structopt</h4>
<p>structopt은 C++ 프로그램에서 명령줄 인수를 처리하기 위한 간단하고 강력한 라이브러리이다. 주요 특징과 사용 방법을 설명드리겠습니다.</p>
<ul>
<li>
<p>간편한 정의: 구조체(struct)를 사용하여 옵션들을 정의하고, 이를 통해 명령줄 인수를 파싱합니다.</p>
</li>
<li>
<p>유연성: 옵션은 위치 인수, 플래그, 매개변수 등으로 정의할 수 있습니다.</p>
</li>
<li>
<p>자동 도움말 생성: 정의된 옵션들을 기반으로 자동으로 도움말 메시지를 생성하여 사용자에게 제공합니다.</p>
</li>
<li>
<p>예외 처리: 잘못된 인수나 옵션을 처리하기 위한 예외 처리 기능을 제공합니다.</p>
</li>
<li>
<p>모던 C++ 지원: C++17 이상의 모던한 C++ 기능을 활용하여 작성되었습니다</p>
</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;include/structopt.hpp&quot;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Options</span> {
    <span class="hljs-type">float</span> number = <span class="hljs-number">0</span>;                   <span class="hljs-comment">// positional parameter</span>
    std::optional&lt;<span class="hljs-type">bool</span>&gt; verbose = <span class="hljs-literal">false</span>;<span class="hljs-comment">// optional flag</span>
    std::optional&lt;<span class="hljs-type">int</span>&gt; round = <span class="hljs-number">2</span>;       <span class="hljs-comment">// optional parameter</span>
};

<span class="hljs-built_in">STRUCTOPT</span>(Options, number, verbose, round);

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">auto</span> app = structopt::<span class="hljs-built_in">app</span>(<span class="hljs-string">&quot;Squaring application&quot;</span>, <span class="hljs-string">&quot;0.0.1&quot;</span>);
        <span class="hljs-keyword">auto</span> options = app.<span class="hljs-built_in">parse</span>&lt;Options&gt;(argc, argv);

        <span class="hljs-keyword">if</span> (options.number == <span class="hljs-number">0</span>) {
            app.<span class="hljs-built_in">help</span>(); <span class="hljs-comment">// 인수가 주어지지 않았을 때 도움말 출력</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (options.verbose.<span class="hljs-built_in">value_or</span>(<span class="hljs-literal">false</span>)) {
                std::cout &lt;&lt; <span class="hljs-string">&quot;verbose is on\n&quot;</span>;
            }
            std::cout &lt;&lt; <span class="hljs-string">&quot;square of: &quot;</span> &lt;&lt; options.number &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt;
                         std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(options.round.<span class="hljs-built_in">value_or</span>(<span class="hljs-number">2</span>)) &lt;&lt;
                         options.number * options.number &lt;&lt; std::endl;
        }
    } <span class="hljs-built_in">catch</span> (structopt::exception&amp; e) {
        std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        std::cout &lt;&lt; e.<span class="hljs-built_in">help</span>(); <span class="hljs-comment">// 예외 발생 시 도움말 출력</span>
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h1 id="lecture-5">Lecture 5</h1>
<h2 id="friends-function">Friends Function</h2>
<p>위에서 봤듯이, private로 선언된 함수나 protected로 선언된 함수 및 변수는 접근하기가 어려웠다. 이때 사용할 수 있는것이 바로 프렌드 함수이다. 클래스의 프렌드 함수는 클래스의 범위 외부에 정의되지만 클래스의 모든 porivate 및 protected 멤버에 접근할 수 있는 권한을 가진다. <strong>프렌드 함수의 프로토타입은 클래스 정의에 나타나지만, 프렌드는 멤버함수가 아니다.</strong> 프렌드는 함수, 함수 템플릿, 멤버 함수, 클래스 또는 클래스 템플릿일 수 있다.</p>
<p>다시 말해, 프렌드 함수는 클래스 외부에 정의되지만, 클래스 정의 부분에서 함수의 원형, 즉 프로토 타입을 선언하여 프렌드로 지정해야 한다. 또한, 선언할 때 <code>friend</code> 키워드를 사용하여 명시해주어야 한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">double</span> width; <span class="hljs-comment">// private 멤버 변수로 박스의 너비를 저장</span>

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// printWidth 함수를 프렌드로 선언하여 이 함수가 private 멤버에 접근할 수 있게 함</span>
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printWidth</span><span class="hljs-params">(Box box)</span></span>;

    <span class="hljs-comment">// 멤버 함수로 width 변수의 값을 설정하는 함수</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> wid)</span> </span>{ 
        width = wid; 
    }
};

<span class="hljs-comment">// 주의: printWidth()는 일반 함수이며, 어떤 클래스의 멤버 함수가 아님</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printWidth</span><span class="hljs-params">(Box box)</span> </span>{
    <span class="hljs-comment">/* printWidth()는 Box 클래스의 프렌드이므로,
       이 클래스의 어떤 멤버에도 직접 접근할 수 있음 */</span>
    cout &lt;&lt; <span class="hljs-string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; endl;
}

<span class="hljs-comment">// 프로그램의 메인 함수</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Box box; <span class="hljs-comment">// Box 클래스의 인스턴스 생성</span>

    <span class="hljs-comment">// 멤버 함수를 사용하여 박스의 너비를 설정</span>
    box.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">10.0</span>);

    <span class="hljs-comment">// 프렌드 함수를 사용하여 박스의 너비를 출력</span>
    <span class="hljs-built_in">printWidth</span>(box);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>프렌드 함수를 사용할 때 주의해야할 점이 있다.</p>
<ul>
<li>프렌드 함수는 제한된 목적으로만 사용해야 한다. 프렌드 함수는 내부 함수에 접근할 수 있어 강력하지만, 이는 잘못 사용하면 encapsulation을 저해할 수 있기 때문에 꼭 필요한 경우에만 사용하는 것이 좋다.</li>
<li>너무 많은 함수나 외부 클래스가 protected 또는 private 데이터를 가진 클래스의 프렌드로 선언되는 것은 바람직 하지 않다. 이는 데이터를 보호하는 본래 목적을 훼손할 수 있다.</li>
<li>프렌드 관계는 상호적이지 않다. 클래스 A가 클래스 B의 프렌드더라도, 클래스 B가 자동으로 클래스의 A의 프렌드가 되거나 하진 않는다.</li>
<li>프렌드 관계는 상속되지 않는다.</li>
<li>자바에는 프렌드 함수가 없다.</li>
</ul>
<h2 id="copy-constructor">Copy Constructor</h2>
<p>카피 생성자는 c++에서 동일한 클래스의 다른 객체를 사용하여 새로운 객체를 초기화하는 특별한 멤버함수이다. 원형은 다음과 같다.</p>
<pre><code class="language-cpp"><span class="hljs-built_in">ClassName</span>(<span class="hljs-type">const</span> ClassName &amp;old_obj);
</code></pre>
<p>copy constructor를 정의하지 않더라도, c++컴파일러는 각 클래스에 대해 default copy constructor를 생성한다. 이 기본 카피 생성자는 객체 간의 멤더 단위 복사를 수행한다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">char</span> *s;
    <span class="hljs-type">int</span> size;

<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 생성자</span>
    ~<span class="hljs-built_in">String</span>() { <span class="hljs-keyword">delete</span> [] s; } <span class="hljs-comment">// 소멸자</span>
    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;oldstr); <span class="hljs-comment">// 복사 생성자</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{ cout &lt;&lt; s &lt;&lt; endl; }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span></span>;
};

<span class="hljs-comment">// 생성자: 문자열을 받아서 객체를 초기화</span>
String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str) {
    size = <span class="hljs-built_in">strlen</span>(str);
    s = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 새로운 메모리 할당</span>
    <span class="hljs-built_in">strcpy</span>(s, str);
}

<span class="hljs-comment">// 문자열을 변경하는 함수</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::change</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> </span>{
    <span class="hljs-keyword">delete</span> [] s;
    size = <span class="hljs-built_in">strlen</span>(str);
    s = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">strcpy</span>(s, str);
}

<span class="hljs-comment">// 복사 생성자: 다른 String 객체를 사용하여 새로운 객체를 초기화</span>
String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;oldstr) {
    size = oldstr.size;
    s = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">1</span>];
    <span class="hljs-built_in">strcpy</span>(s, oldstr.s);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">String <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;GeeksQuiz&quot;</span>)</span></span>; <span class="hljs-comment">// String 객체 str1 생성</span>
    String str2 = str1; <span class="hljs-comment">// 복사 생성자 호출, str1을 사용하여 str2 초기화</span>
    str1.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// str1 출력: &quot;GeeksQuiz&quot;</span>
    str2.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// str2 출력: &quot;GeeksQuiz&quot;</span>

    str2.<span class="hljs-built_in">change</span>(<span class="hljs-string">&quot;GeeksforGeeks&quot;</span>); <span class="hljs-comment">// str2의 문자열을 변경</span>
    str1.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// str1 출력: &quot;GeeksQuiz&quot;</span>
    str2.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// str2 출력: &quot;GeeksforGeeks&quot;</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>기본으로 자동으로 생성되는 디폴트 copy 콘스트럭터는 <code>shallow copy</code>를 수행한다. 즉, 객체의 모든 멤버 변수를 그대로 복사한다. 만약 객체가 포인터나 동적 할당된 메모리를 포함하고 있다면, shallow copy는 이런 자원을 공유하게 되어 예기치 않은 동작을 유발할 수 있다.</p>
<p>이런 경우를 대비하여, <code>deep copy</code>를 수행하는 카피 컨스트럭터를 정의할 수 있다. deep copy는 객체의 멤버가 가리키는 메모리도 새로 할당하여 복사한다.</p>
<p>위의 코드는 복사 생성자를 두개 넣어서 deep copy를 수행하는데, 위의, 클래스 내의 복사 생성자를 제거할 경우 shallow copy가 쓰이게 되어 위에 말한 문제가 생길 수 있다. 조심하자.</p>
<h2 id="this-pointer">This pointer</h2>
<p><code>this</code> 포인터는 C++에서 모든 객체가 자신의 주소에 접근할 수 있게 하는 중요한 포인터이다. <code>this</code> 포인터는 모든 멤버 함수의 암시적 매개변수이다. 따라서, 멤버 함수 내부에서 <code>this</code>를 사용하여 호출 객체를 참조할 수 있다. 프렌드 함수는 클래스의 멤버 함수가 아니기 때문에 <code>this</code> 포인터를 가지지 않는다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 생성자 정의</span>
    <span class="hljs-built_in">Box</span>(<span class="hljs-type">double</span> l = <span class="hljs-number">2.0</span>, <span class="hljs-type">double</span> b = <span class="hljs-number">2.0</span>, <span class="hljs-type">double</span> h = <span class="hljs-number">2.0</span>) {
        cout &lt;&lt; <span class="hljs-string">&quot;Constructor called.&quot;</span> &lt;&lt; endl;
        length = l;
        breadth = b;
        height = h;
    }
    
    <span class="hljs-comment">// 부피를 계산하는 멤버 함수</span>
    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Volume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> length * breadth * height;
    }
    
    <span class="hljs-comment">// Box 객체를 비교하는 멤버 함수</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Box box)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Volume</span>() &gt; box.<span class="hljs-built_in">Volume</span>();
        <span class="hljs-comment">// this를 통해 호출 객체의 부피와, 매개변수로 전달된 객체의 부피를 비교한다. </span>
        <span class="hljs-comment">// this -&gt; Volume()은 호출 객체의 부피를 참조한다. </span>
    }

    <span class="hljs-comment">// `this` 포인터를 사용하지 않고 Box 객체를 비교하는 멤버 함수</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare2</span><span class="hljs-params">(Box box)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Volume</span>() &gt; box.<span class="hljs-built_in">Volume</span>();
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-type">double</span> length;  <span class="hljs-comment">// 박스의 길이</span>
    <span class="hljs-type">double</span> breadth; <span class="hljs-comment">// 박스의 너비</span>
    <span class="hljs-type">double</span> height;  <span class="hljs-comment">// 박스의 높이</span>
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{
    <span class="hljs-function">Box <span class="hljs-title">Box1</span><span class="hljs-params">(<span class="hljs-number">3.3</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.5</span>)</span></span>; <span class="hljs-comment">// Box1 선언 및 초기화</span>
    <span class="hljs-function">Box <span class="hljs-title">Box2</span><span class="hljs-params">(<span class="hljs-number">8.5</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">2.0</span>)</span></span>; <span class="hljs-comment">// Box2 선언 및 초기화</span>

    <span class="hljs-comment">// Box1과 Box2를 비교하여 결과 출력</span>
    <span class="hljs-keyword">if</span> (Box1.<span class="hljs-built_in">compare</span>(Box2)) {
        cout &lt;&lt; <span class="hljs-string">&quot;Box2 is smaller than Box1&quot;</span> &lt;&lt; endl;
    } <span class="hljs-keyword">else</span> {
        cout &lt;&lt; <span class="hljs-string">&quot;Box2 is equal to or larger than Box1&quot;</span> &lt;&lt; endl;
    }

    <span class="hljs-comment">// compare 함수와 compare2 함수의 결과를 출력</span>
    cout &lt;&lt; <span class="hljs-string">&quot;compare: &quot;</span> &lt;&lt; Box1.<span class="hljs-built_in">compare</span>(Box2) &lt;&lt; <span class="hljs-string">&quot; compare2: &quot;</span> &lt;&lt; Box1.<span class="hljs-built_in">compare2</span>(Box2) &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>언제 <code>this</code>를 사용해아할까?</p>
<p>보통 로컬 변수의 이름이 member의 이름과 같을때 <code>this -&gt; x = x</code>처럼 사용하고, 호출 객체에 참조를 리턴해야할 때 <code>*this</code>처럼 사용한다.</p>
<h2 id="operator-overloading">Operator overloading</h2>
<p>오퍼레이터 오버로딩은 C++에서 사용자가 정의한 타입에 대해 내장 연산자를 재정의할 수 있는 기능이다. 이를 통해 사용자 정의 타입에 대해서도 산술 연산, 비교 연산 등을 사용할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getVolume</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{
        <span class="hljs-keyword">return</span> length * breadth * height;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> len)</span> </span>{
        length = len;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBreadth</span><span class="hljs-params">(<span class="hljs-type">double</span> bre)</span> </span>{
        breadth = bre;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> hei)</span> </span>{
        height = hei;
    }

    <span class="hljs-comment">// + 연산자 오버로딩: 두 Box 객체를 더한 결과를 반환</span>
    Box <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Box&amp; b) {
        Box box;
        box.length = <span class="hljs-keyword">this</span>-&gt;length + b.length;
        box.breadth = <span class="hljs-keyword">this</span>-&gt;breadth + b.breadth;
        box.height = <span class="hljs-keyword">this</span>-&gt;height + b.height;
        <span class="hljs-keyword">return</span> box;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-type">double</span> length;  <span class="hljs-comment">// 상자의 길이</span>
    <span class="hljs-type">double</span> breadth; <span class="hljs-comment">// 상자의 너비</span>
    <span class="hljs-type">double</span> height;  <span class="hljs-comment">// 상자의 높이</span>
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Box Box1; <span class="hljs-comment">// Box1 객체 생성</span>
    Box Box2; <span class="hljs-comment">// Box2 객체 생성</span>
    Box Box3; <span class="hljs-comment">// Box3 객체 생성</span>

    <span class="hljs-comment">// Box1 사양 설정</span>
    Box1.<span class="hljs-built_in">setLength</span>(<span class="hljs-number">6.0</span>);
    Box1.<span class="hljs-built_in">setBreadth</span>(<span class="hljs-number">7.0</span>);
    Box1.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">5.0</span>);

    <span class="hljs-comment">// Box2 사양 설정</span>
    Box2.<span class="hljs-built_in">setLength</span>(<span class="hljs-number">12.0</span>);
    Box2.<span class="hljs-built_in">setBreadth</span>(<span class="hljs-number">13.0</span>);
    Box2.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">10.0</span>);

    <span class="hljs-comment">// Box1의 부피 계산 및 출력</span>
    <span class="hljs-type">double</span> volume = Box1.<span class="hljs-built_in">getVolume</span>();
    cout &lt;&lt; <span class="hljs-string">&quot;Volume of Box1: &quot;</span> &lt;&lt; volume &lt;&lt; endl;

    <span class="hljs-comment">// Box2의 부피 계산 및 출력</span>
    volume = Box2.<span class="hljs-built_in">getVolume</span>();
    cout &lt;&lt; <span class="hljs-string">&quot;Volume of Box2: &quot;</span> &lt;&lt; volume &lt;&lt; endl;

    <span class="hljs-comment">// 두 상자를 더하여 Box3에 할당</span>
    Box3 = Box1 + Box2;

    <span class="hljs-comment">// Box3의 부피 계산 및 출력</span>
    volume = Box3.<span class="hljs-built_in">getVolume</span>();
    cout &lt;&lt; <span class="hljs-string">&quot;Volume of Box3: &quot;</span> &lt;&lt; volume &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>요렇게, 그냥 원하는 연산자를 <code>operator</code>키워드와 붙여서 쓰면 된다. 만약 <code>+</code>를 오버로딩 하고싶으면 뭐 예를들어 <code>int operator+</code>, 다른거라면 뭐 <code>bool operator==</code>등이 있겠다.</p>
<p>연산자를 오버로딩 하는 경우는 실제로는 매우 드물다. 대부분의 연산자는 해당 연산의 직관적인 의미를 유지하며 사용된다. 무분별한 오버로딩은 혼란을 초래할 수 있다.</p>
<h2 id="namespace">Namespace</h2>
<p>네임스페이스(namespace)는 C++에서 식별자를 논리적으로 그룹화하여 충돌을 방지하고 코드를 구조화하는 데 사용되는 메커니즘이다. 네임스페이스는 전역 범위에서 정의되며, 다음과 같은 이점을 제공한다.</p>
<ul>
<li><strong>식별자 충돌 방지</strong>: 다양한 소스에서 사용되는 식별자들을 네임스페이스 내에서 격리함으로써 충돌을 방지한다.</li>
<li><strong>코드 구조화</strong>: 관련된 함수, 변수, 클래스 등을 하나의 네임스페이스에 묶어 코드를 더 쉽게 관리할 수 있다.</li>
<li><strong>가독성 및 유지보수성</strong>: 코드의 구조가 명확해지고, 코드의 의도가 명백해지므로 가독성이 향상되고 유지보수가 용이해진다.</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// first name space</span>
<span class="hljs-keyword">namespace</span> first_space {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
        cout &lt;&lt; <span class="hljs-string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;
    }
}

<span class="hljs-comment">// second name space</span>
<span class="hljs-keyword">namespace</span> second_space {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
        cout &lt;&lt; <span class="hljs-string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Calls function from first name space.</span>
    first_space::<span class="hljs-built_in">func</span>();

    <span class="hljs-comment">// Calls function from second name space.</span>
    second_space::<span class="hljs-built_in">func</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>요렇게 네임스페이스 안에 함수를 가두면, 네임스페이스를 명시하고 그 다음 함수를 호출해야 하기 때문에, 함수들의 이름이 같더라도 각각 다른 함수를 호출할 수 있다.</p>
<p>이런 네임스페이스는 <code>using namespace std;</code>와 같은 코드를 통해 네임스페이스 전체를 가져올 수 있고, 네임스페이스 명시를 생략하여 사용할 수 있다. 그러나 이와같은 방법은 식별자 충돌을 초래할 수 있으므로 주의해야한다.</p>
<h3 id="nested-namespace">Nested namespace</h3>
<p>네임스페이스 안에 네임스페이스를 중첩하여 사용할 수 있다.</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// 첫 번째 네임스페이스</span>
<span class="hljs-keyword">namespace</span> first_space {
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
        cout &lt;&lt; <span class="hljs-string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;
    }

    <span class="hljs-comment">// 첫 번째 네임스페이스 안에 중첩된 두 번째 네임스페이스</span>
    <span class="hljs-keyword">namespace</span> second_space {
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
            cout &lt;&lt; <span class="hljs-string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;
        }
    }
}

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> first_space::second_space;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 두 번째 네임스페이스에 있는 함수 호출</span>
    <span class="hljs-built_in">func</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>복잡한 코드의 구조를 효과적으로 관리할 수 있는 방법이다. 정리충 애들이 좋아할 것 같은 방법임.</p>
<p><strong>정리</strong></p>
<ul>
<li>
<p><strong>코드 구조화 및 정리</strong>: 네임스페이스를 사용하면 코드를 더욱 체계적으로 구조화할 수 있습니다. 관련된 변수, 함수, 클래스를 함께 그룹화하여 관리할 수 있습니다.</p>
</li>
<li>
<p><strong>이름 충돌 회피</strong>: 서로 다른 네임스페이스에 동일한 이름을 사용하여 이름 충돌을 피할 수 있습니다. 이는 큰 프로젝트에서 특히 중요합니다.</p>
</li>
<li>
<p><strong>관련 기능 집중</strong>: 네임스페이스를 사용하면 관련된 기능을 하나의 네임스페이스 안에 집중시킬 수 있습니다. 예를 들어, 파일 시스템 관련 기능은 std::filesystem 네임스페이스 안에 모을 수 있습니다.</p>
</li>
<li>
<p><strong>여러 파일에서 네임스페이스 확장</strong>: 네임스페이스는 여러 파일에 걸쳐 확장할 수 있으며, 이는 코드의 재사용성과 유지보수성을 높이는 데 도움을 줍니다.</p>
</li>
<li>
<p><strong>현재 스코프에 네임스페이스 가져오기</strong>: using 키워드를 사용하여 특정 네임스페이스의 범위를 현재 스코프로 가져올 수 있습니다. 이는 코드를 간결하게 만들고 타이핑을 줄이는 데 도움을 줍니다.</p>
</li>
<li>
<p><strong>네임스페이스 별칭</strong>: 네임스페이스의 긴 이름을 짧게 줄여서 사용할 수 있습니다. 이는 코드를 읽기 쉽게 만들어주며, 복잡한 구조의 네임스페이스를 간단하게 다룰 수 있습니다.</p>
</li>
<li>
<p><strong>대규모 프로젝트에서의 권장</strong>: 작은 프로젝트보다는 대규모 프로젝트에서 네임스페이스 사용이 권장됩니다. 코드의 구조화와 관리가 더욱 중요해지기 때문이다.</p>
</li>
<li>
<p><strong>함수 선언과 정의</strong>: 네임스페이스 안에서 함수를 선언하고 외부에서 정의할 수 있습니다. 이는 네임스페이스 안에서의 인터페이스 분리와 구현의 분리를 가능하게 합니다.</p>
</li>
<li>
<p><strong>네임스페이스의 파일 구조</strong>: 네임스페이스가 여러 파일로 구성되어 있는 경우, 해당 네임스페이스와 동일한 이름의 폴더 안에 네임스페이스 파일들을 위치시키는 것이 일반적이다.</p>
</li>
<li>
<p><strong>C++ 네임스페이스의 편리함</strong>: C++의 네임스페이스는 R과 같은 다른 언어의 네임스페이스보다 훨씬 편리합니다. 예를 들어, 모든 함수의 자동 import가 없으며, 네임스페이스의 생성과 중첩이 더 간단합니다.</p>
</li>
</ul>
<h2 id="function-template">Function Template</h2>
<p>템플릿은 C++에서 제공하는 기능으로, 여러 데이터 타입에 대해 동작할 수 있는 함수나 클래스를 정의할 수 있게한다. 지금까지 변수에 대한 템플릿은 알아봤는데, 템플릿은 사실 함수나 클래스에도 사용이 가능하다.</p>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(T <span class="hljs-type">const</span>&amp; a, T <span class="hljs-type">const</span>&amp; b)</span> </span>{
    <span class="hljs-keyword">return</span> a &lt; b ? b : a;
}
</code></pre>
<p>요래 사용이 가능하다.</p>
<h2 id="class-template">Class Template</h2>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-comment">// 템플릿 클래스 Stack 정의</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> {
<span class="hljs-keyword">private</span>:
    vector&lt;T&gt; elems; <span class="hljs-comment">// 요소들을 저장하는 벡터</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T <span class="hljs-type">const</span> &amp;elem)</span></span>; <span class="hljs-comment">// 요소를 스택에 추가하는 함수</span>
    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 스택에서 요소를 제거하고 반환하는 함수</span>
    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 스택의 맨 위 요소를 반환하는 함수</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 스택이 비어있는지 여부를 반환하는 함수</span>
};

<span class="hljs-comment">// push 함수 정의: 요소를 스택에 추가</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">void</span> Stack&lt;T&gt;::<span class="hljs-built_in">push</span>(T <span class="hljs-type">const</span>&amp; elem) {
    elems.<span class="hljs-built_in">push_back</span>(elem); <span class="hljs-comment">// 벡터에 요소 추가</span>
}

<span class="hljs-comment">// pop 함수 정의: 스택에서 요소를 제거하고 반환</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
T Stack&lt;T&gt;::<span class="hljs-built_in">pop</span>() {
    <span class="hljs-keyword">if</span> (elems.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">// 스택이 비어있는 경우 예외 처리</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;T&gt;::pop(): empty stack&quot;</span>);
    T elem = <span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 맨 위 요소를 얻어옴</span>
    elems.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 벡터에서 마지막 요소 제거</span>
    <span class="hljs-keyword">return</span> elem; <span class="hljs-comment">// 제거한 요소 반환</span>
}

<span class="hljs-comment">// top 함수 정의: 스택의 맨 위 요소 반환</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
T Stack&lt;T&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span> {
    <span class="hljs-keyword">if</span> (elems.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">// 스택이 비어있는 경우 예외 처리</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>);
    <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 벡터의 마지막 요소 반환</span>
}

<span class="hljs-comment">// empty 함수 정의: 스택이 비어있는지 여부 반환</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-type">bool</span> Stack&lt;T&gt;::<span class="hljs-built_in">empty</span>() <span class="hljs-type">const</span> {
    <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 벡터의 empty() 함수 호출하여 결과 반환</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        Stack&lt;<span class="hljs-type">int</span>&gt; intStack; <span class="hljs-comment">// 정수형 스택 생성</span>
        Stack&lt;string&gt; stringStack; <span class="hljs-comment">// 문자열 스택 생성</span>

        <span class="hljs-comment">// 정수형 스택 조작</span>
        intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">7</span>);
        intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">9</span>);
        cout &lt;&lt; <span class="hljs-string">&quot;Top of intStack: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">top</span>() &lt;&lt; endl;

        <span class="hljs-comment">// 문자열 스택 조작</span>
        stringStack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;Hello&quot;</span>);
        stringStack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;World!&quot;</span>);
        cout &lt;&lt; <span class="hljs-string">&quot;Top of stringStack: &quot;</span> &lt;&lt; stringStack.<span class="hljs-built_in">top</span>() &lt;&lt; endl;
        cout &lt;&lt; <span class="hljs-string">&quot;Popped element from stringStack: &quot;</span> &lt;&lt; stringStack.<span class="hljs-built_in">pop</span>() &lt;&lt; endl;

        <span class="hljs-comment">// 스택이 비어있는 경우</span>
        stringStack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 두 번 pop() 호출하여 스택 비우기</span>
        stringStack.<span class="hljs-built_in">pop</span>(); 

    } <span class="hljs-built_in">catch</span> (exception <span class="hljs-type">const</span>&amp; ex) {
        cout &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; endl; <span class="hljs-comment">// 예외 처리</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>아 근데 나는 진짜 템플릿은 알다가도 모르겠다.</p>
<h2 id="standard-template-library-stl">Standard Template Library (STL)</h2>
<p>STL(Standard Template Library)은 C++ 프로그래밍 언어를 위한 표준 라이브러리이다. 이 라이브러리는 C++ 표준에 포함되어 있으며, 다음 네 가지 주요 구성 요소를 제공한다.</p>
<ul>
<li>
<p>알고리즘 (Algorithms):</p>
<ul>
<li>STL은 다양한 알고리즘을 제공합니다. 예를 들어, 정렬(sorting), 검색(searching), 변형(transforming) 등의 알고리즘을 포함합니다. 이 알고리즘들은 일반적으로 사용되는 작업들을 구현하여 제공하며, 데이터 처리를 간편하게 할 수 있습니다.</li>
</ul>
</li>
<li>
<p>컨테이너 (Containers):</p>
<ul>
<li>
<p>컨테이너는 데이터를 저장하고 관리하는 객체들을 말합니다. STL은 다양한 종류의 컨테이너를 제공하는데, 배열(array), 리스트(list), 벡터(vector), 맵(map), 세트(set) 등이 있습니다. 각 컨테이너는 특정 데이터 구조를 구현하여 데이터를 효율적으로 저장하고 접근할 수 있게 합니다.</p>
</li>
<li>
<p><code>std::vector</code>: 동적 배열을 제공하며, 원소의 끝에 삽입 및 삭제가 빠르게 가능합니다.</p>
</li>
<li>
<p><code>std::deque</code>: 덱(Deque)은 double-ended queue의 약어로, 양 끝에서 원소의 추가와 제거가 O(1) 시간에 가능한 자료구조이다.</p>
</li>
<li>
<p><code>std::list</code>: 이중 연결 리스트를 구현한 자료구조로, 임의 위치에서의 원소 삽입과 삭제가 O(1) 시간에 가능합니다.</p>
</li>
<li>
<p><code>std::set</code>: 균형 이진 검색 트리로 구현된 자료구조로, 중복을 허용하지 않고 원소를 정렬된 상태로 유지합니다.</p>
</li>
<li>
<p><code>std::map</code>: 키와 값을 한 쌍으로 저장하는 자료구조로, 키를 기준으로 정렬되어 있으며 중복을 허용하지 않습니다.</p>
</li>
<li>
<p><code>std::unordered_set</code>: 해시 테이블을 사용하여 구현된 자료구조로, 원소의 삽입, 삭제, 검색 등이 상수 시간에 이루어집니다.</p>
</li>
<li>
<p><code>std::unordered_map</code>: 해시 테이블을 사용하여 구현된 맵으로, 키를 기준으로 중복 없이 값을 저장하며 상수 시간에 삽입, 삭제, 검색이 가능합니다.</p>
</li>
<li></li>
</ul>
</li>
<li>
<p>함수 (Functions):</p>
<ul>
<li>STL은 함수 객체(function objects)와 함수 포인터(function pointers)를 포함한 다양한 함수를 제공합니다. 이러한 함수들은 알고리즘과 컨테이너에서 사용될 수 있으며, 일반 함수 또는 람다 표현식(lambda expressions)으로 구현될 수 있습니다.</li>
<li>대표적으로 <code>std::sort</code>, <code>std::find</code>, <code>std::transform</code>등이 있다.</li>
</ul>
</li>
<li>
<p>이터레이터 (Iterators):</p>
<ul>
<li>이터레이터는 컨테이너의 요소를 순회(traverse)하고 접근(access)하기 위한 인터페이스를 제공합니다. STL에서 제공하는 이터레이터들은 포인터와 유사하게 동작하며, 컨테이너의 요소에 접근하여 작업을 수행할 수 있습니다.</li>
</ul>
</li>
</ul>
<h3 id="set-vs-vector-vs-map">Set vs Vector vs Map</h3>
<ul>
<li>
<p><strong>std::set</strong>:</p>
<ul>
<li><code>std::set</code>은 정렬된 유일한 값을 갖는 컨테이너이다. 중복된 값이 삽입되지 않으며, 항목들이 자동으로 정렬됩니다.</li>
<li>여러 항목을 한 번에 삽입할 때 <code>std::set</code>이 더 빠릅니다.</li>
<li>항목이 정렬된 순서로 유지되어야 할 경우에 사용됩니다.</li>
<li>성능이 매우 중요한 경우에 사용될 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>std::vector</strong>:</p>
<ul>
<li><code>std::vector</code>는 동적 배열을 나타내며, 요소를 순차적으로 저장합니다. 크기가 동적으로 조절되며, 중간 삽입 및 삭제가 비효율적일 수 있습니다.</li>
<li>자료를 순차적으로 접근해야 할 때 유용하며, 순서가 중요한 경우에도 사용될 수 있습니다.</li>
<li>많은 경우에서 기본적으로 사용되는 컨테이너이다.</li>
</ul>
</li>
<li>
<p><strong>std::map</strong>:</p>
<ul>
<li><code>std::map</code>은 key-value 쌍으로 데이터를 저장하는 연관 컨테이너이다. key는 유일해야 하며, 자동으로 정렬됩니다.</li>
<li>데이터를 검색할 때 효율적이며, key에 따라 자동으로 정렬되어야 할 경우에 사용됩니다.</li>
<li><code>std::multimap</code>은 하나의 key에 여러 개의 값이 매핑될 수 있습니다. 이는 <code>std::map</code>에 <code>std::vector</code>를 값으로 사용하여 구현할 수 있습니다.</li>
</ul>
</li>
<li>
<p>추가 설명:</p>
<ul>
<li><code>std::array</code>는 정적 배열로 크기가 고정되어 있으며, <code>std::vector</code>보다 메모리 관리나 크기 조정 면에서 제약이 있습니다.</li>
<li><code>std::multimap</code>은 <code>std::map</code>에 <code>std::vector</code>를 값으로 사용하여 다수의 값들을 한 key에 연결할 수 있습니다. 이는 반복문에서 더 쉽게 처리할 수 있습니다.</li>
<li>일반적으로, 대부분의 상황에서는 <code>std::vector</code>와 <code>std::map</code>을 사용하는 것이 권장됩니다. 이 두 컨테이너는 유연성과 성능 면에서 매우 우수합니다.</li>
</ul>
</li>
</ul>
<h3 id="pair-and-tuple">Pair and Tuple</h3>
<p>새로 생긴 애들인가보다.</p>
<ul>
<li>
<p><strong>std::tuple</strong>:</p>
<ul>
<li><code>std::tuple</code>은 C++ 표준 라이브러리에서 제공하는 클래스로, 다양한 타입의 여러 값을 하나의 단위로 저장할 수 있습니다.</li>
<li>예를 들어, <code>std::tuple&lt;int, std::string, double&gt;</code>은 정수, 문자열, 실수 세 가지 타입의 값을 저장할 수 있는 구조체이다.</li>
<li><code>std::make_tuple</code> 함수를 사용하여 tuple을 생성할 수 있습니다. 이 함수는 전달된 값들로부터 tuple을 만들어 반환합니다.</li>
</ul>
</li>
<li>
<p><strong>std::pair</strong>:</p>
<ul>
<li><code>std::pair</code>는 두 개의 값, 동일한 타입 또는 다른 타입의 두 값을 저장할 수 있는 클래스이다.</li>
<li>예를 들어, <code>std::pair&lt;int, std::string&gt;</code>은 정수와 문자열 한 쌍을 저장할 수 있습니다.</li>
<li><code>std::make_pair</code> 함수를 사용하여 pair를 생성할 수 있습니다. 이 함수는 두 개의 값으로부터 pair를 만들어 반환합니다.</li>
</ul>
</li>
</ul>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>